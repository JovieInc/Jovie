#!/usr/bin/env node

/**
 * Auto-Unquarantine Tests
 *
 * Automatically removes tests from quarantine after N consecutive successful runs.
 * Prevents stale quarantine entries and reduces manual maintenance.
 *
 * Usage:
 *   node auto-unquarantine.js <github-token> <owner> <repo>
 *
 * Environment:
 *   - GITHUB_TOKEN: GitHub API token
 *   - GITHUB_REPOSITORY: owner/repo
 *   - CONSECUTIVE_SUCCESS_THRESHOLD: Number of successful runs to trigger unquarantine (default: 5)
 */

const fs = require('fs');
const path = require('path');

// Configuration
const CONSECUTIVE_SUCCESS_THRESHOLD =
  parseInt(process.env.CONSECUTIVE_SUCCESS_THRESHOLD) || 5;
const QUARANTINE_FILE_PATH = path.join(
  process.cwd(),
  'apps/web/quarantine.json'
);

/**
 * Load quarantine.json file
 */
function loadQuarantineFile() {
  if (!fs.existsSync(QUARANTINE_FILE_PATH)) {
    console.log('No quarantine.json file found. Nothing to unquarantine.');
    return null;
  }

  try {
    const content = fs.readFileSync(QUARANTINE_FILE_PATH, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.error(`Failed to parse quarantine.json: ${error.message}`);
    return null;
  }
}

/**
 * Save updated quarantine.json file
 */
function saveQuarantineFile(data) {
  try {
    fs.writeFileSync(
      QUARANTINE_FILE_PATH,
      JSON.stringify(data, null, 2) + '\n'
    );
    return true;
  } catch (error) {
    console.error(`Failed to save quarantine.json: ${error.message}`);
    return false;
  }
}

/**
 * Analyze test results from flakiness report to track consecutive successes
 */
async function analyzeTestSuccess() {
  // Read the flakiness report generated by analyze-test-flakiness.js
  const reportPath = path.join(process.cwd(), 'flakiness-report.md');

  if (!fs.existsSync(reportPath)) {
    console.log('No flakiness report found. Skipping auto-unquarantine.');
    return {};
  }

  const report = fs.readFileSync(reportPath, 'utf8');

  // Parse the report to extract test success data
  // For now, we'll use a simple heuristic: if a test is NOT in the flaky tests table,
  // it has been passing consistently

  const flakyTestsMatch = report.match(/## Flaky Tests \((\d+)\)/);
  const flakyCount = flakyTestsMatch ? parseInt(flakyTestsMatch[1]) : 0;

  console.log(`üìä Found ${flakyCount} flaky tests in current report`);

  // Extract flaky test names from table
  const flakyTests = new Set();
  const tableRegex = /\| [üî¥üü°üü¢] \w+ \| `(.+?)` \|/g;
  let match;

  while ((match = tableRegex.exec(report)) !== null) {
    flakyTests.add(match[1]);
  }

  return { flakyTests };
}

/**
 * Update quarantine entries and remove tests that have been passing
 */
async function processQuarantine() {
  console.log('üîÑ Processing quarantine file for auto-unquarantine...\n');

  const quarantineData = loadQuarantineFile();
  if (!quarantineData || !quarantineData.tests) {
    return { unquarantined: [], updated: false };
  }

  const { flakyTests } = await analyzeTestSuccess();
  const unquarantined = [];
  const updatedTests = quarantineData.tests.filter(entry => {
    const testName = entry.test || entry.name;

    // If test is in flaky tests list, reset its success counter
    if (flakyTests.has(testName)) {
      if (entry.consecutiveSuccesses) {
        console.log(
          `   ‚ö†Ô∏è  ${testName}: Still flaky, resetting success counter`
        );
        entry.consecutiveSuccesses = 0;
      }
      return true; // Keep in quarantine
    }

    // Test is not flaky - increment success counter
    entry.consecutiveSuccesses = (entry.consecutiveSuccesses || 0) + 1;

    if (entry.consecutiveSuccesses >= CONSECUTIVE_SUCCESS_THRESHOLD) {
      console.log(
        `   ‚úÖ ${testName}: ${entry.consecutiveSuccesses} consecutive successes - UNQUARANTINING`
      );
      unquarantined.push(testName);
      return false; // Remove from quarantine
    }

    console.log(
      `   üîÑ ${testName}: ${entry.consecutiveSuccesses}/${CONSECUTIVE_SUCCESS_THRESHOLD} consecutive successes`
    );
    return true; // Keep in quarantine
  });

  // Save updated quarantine file
  const updated =
    unquarantined.length > 0 ||
    updatedTests.length !== quarantineData.tests.length;

  if (updated) {
    quarantineData.tests = updatedTests;
    quarantineData.lastUpdated = new Date().toISOString();

    if (saveQuarantineFile(quarantineData)) {
      console.log(
        `\n‚úÖ Updated quarantine.json (${unquarantined.length} tests removed)`
      );
    } else {
      console.error('\n‚ùå Failed to save quarantine.json');
      return { unquarantined: [], updated: false };
    }
  }

  return { unquarantined, updated };
}

/**
 * Main execution
 */
async function main() {
  try {
    console.log('ü§ñ Auto-Unquarantine Tests\n');
    console.log(
      `   Threshold: ${CONSECUTIVE_SUCCESS_THRESHOLD} consecutive successes\n`
    );

    const result = await processQuarantine();

    if (result.unquarantined.length > 0) {
      console.log('\nüìã Summary:');
      console.log(
        `   Removed ${result.unquarantined.length} tests from quarantine:`
      );
      result.unquarantined.forEach(test => {
        console.log(`   - ${test}`);
      });

      // Set output for GitHub Actions
      if (process.env.GITHUB_OUTPUT) {
        const output = [
          `unquarantined_count=${result.unquarantined.length}`,
          `unquarantined_tests=${result.unquarantined.join(',')}`,
        ].join('\n');
        fs.appendFileSync(process.env.GITHUB_OUTPUT, output + '\n');
      }
    } else {
      console.log('\n‚ú® No tests ready for unquarantine');
    }

    process.exit(0);
  } catch (error) {
    console.error(`‚ùå Error: ${error.message}`);
    process.exit(1);
  }
}

// Run if executed directly
if (require.main === module) {
  main();
}

module.exports = { processQuarantine };
