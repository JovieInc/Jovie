name: 'Check Path Changes'
description: 'Determines if CI should run based on changed file paths'

inputs:
  job-type:
    description: 'Type of job (build, test, e2e, drizzle)'
    required: true
  full-ci-label:
    description: 'Whether testing label is present (force full CI)'
    required: false
    default: 'false'
  base-ref:
    description: 'Base branch reference'
    required: false
    default: ''
  event-name:
    description: 'GitHub event name'
    required: true
  is-fork:
    description: 'Whether this is a fork PR'
    required: false
    default: 'false'

outputs:
  run_full_ci:
    description: 'Whether to run full CI'
    value: ${{ steps.check.outputs.run_full_ci }}

runs:
  using: 'composite'
  steps:
    - name: Check for relevant changes
      id: check
      shell: bash
      run: |
        # Force run if the configured force-full-CI label is present
        if [[ "${{ inputs.full-ci-label }}" == "true" ]]; then
          echo "Forcing full CI run due to 'testing' label"
          echo "run_full_ci=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Skip on fork PRs where repo secrets are unavailable (except for drizzle which has its own DB handling)
        if [[ "${{ inputs.event-name }}" == "pull_request" && "${{ inputs.is-fork }}" == "true" && "${{ inputs.job-type }}" != "drizzle" ]]; then
          echo "Fork PR detected; skipping ${{ inputs.job-type }} job to avoid missing secrets."
          echo "run_full_ci=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # For PRs to production, always run full CI (skip path guards)
        if [[ "${{ inputs.event-name }}" == "pull_request" && "${{ inputs.base-ref }}" == "production" ]]; then
          echo "Running full CI for PR to production branch"
          echo "run_full_ci=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        # For merge queue events, always run full CI
        if [[ "${{ inputs.event-name }}" == "merge_group" ]]; then
          echo "Running full CI for merge queue"
          echo "run_full_ci=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        # For push events to production/preview, always run full CI
        if [[ "${{ inputs.event-name }}" == "push" && ("$GITHUB_REF" == "refs/heads/production" || "$GITHUB_REF" == "refs/heads/preview") ]]; then
          echo "Running full CI for push to production/preview branch"
          echo "run_full_ci=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Determine changed files depending on event type
        if [[ "${{ inputs.event-name }}" == "pull_request" ]]; then
          # For PRs, compare against the base ref from origin
          git fetch origin "${{ inputs.base-ref }}"
          CHANGED_FILES=$(git diff --name-only "origin/${{ inputs.base-ref }}" HEAD)
        else
          # For push/merge_group, compare with previous commit
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
        fi

        # Skip if only documentation/config files changed
        if echo "$CHANGED_FILES" | grep -v -E '\.(md|txt|yml|yaml)$' | wc -l | grep -q '^0$'; then
          echo "Only documentation files changed, skipping ${{ inputs.job-type }}"
          echo "run_full_ci=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Define path patterns based on job type (monorepo aware - apps/web/ prefix)
        case "${{ inputs.job-type }}" in
          "build")
            PATTERN='^(apps/web/app/|apps/web/components/|apps/web/lib/|apps/web/hooks/|apps/web/types/|apps/web/constants/|apps/web/package.*\.json|apps/web/next\.config\.js|apps/web/tailwind\.config\.|apps/web/postcss\.config\.|package.*\.json|turbo\.json)'
            ;;
          "test")
            PATTERN='^(apps/web/app/|apps/web/components/|apps/web/lib/|apps/web/hooks/|apps/web/types/|apps/web/tests/unit/|apps/web/__tests__/|.*\.test\.|.*\.spec\.|apps/web/package.*\.json|apps/web/vitest\.config\.|package.*\.json)'
            ;;
          "e2e")
            PATTERN='^(apps/web/app/|apps/web/components/|apps/web/tests/e2e/|apps/web/tests/smoke/|apps/web/playwright\.config\.|apps/web/package.*\.json|package.*\.json)'
            ;;
          "drizzle")
            PATTERN='^(apps/web/drizzle/|apps/web/lib/db/|apps/web/lib/db/schema|apps/web/drizzle\.config\.ts|apps/web/drizzle/config\.ts|drizzle\.kit\.(m?js|ts)|package(-lock)?\.json|pnpm-lock\.yaml)'
            ;;
          *)
            # Default pattern
            PATTERN='^(apps/web/app/|apps/web/components/|apps/web/lib/|apps/web/hooks/|apps/web/types/|apps/web/constants/|apps/web/package.*\.json|apps/web/next\.config\.js|package.*\.json)'
            ;;
        esac

        # Check if relevant paths were modified
        echo "Checking for changes in ${{ inputs.job-type }} paths..."
        echo "Pattern: $PATTERN"
        
        if echo "$CHANGED_FILES" | grep -q -E "$PATTERN"; then
          echo "Relevant paths changed, running ${{ inputs.job-type }}"
          echo "run_full_ci=true" >> $GITHUB_OUTPUT
        else
          echo "No relevant paths changed, skipping ${{ inputs.job-type }}"
          echo "run_full_ci=false" >> $GITHUB_OUTPUT
          echo "Changed files:"
          echo "$CHANGED_FILES"
        fi