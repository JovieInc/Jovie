name: Smart Auto-Merge

# Consolidated auto-merge workflow for all PR types targeting main branch
# Handles: Dependabot, Codegen, and regular PRs with intelligent branch updating

"on":
  pull_request_target:
    types: [opened, edited, synchronize, labeled, unlabeled, ready_for_review]
    branches: [main]
  workflow_run:
    workflows: ['CI']
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  actions: read

concurrency:
  group: auto-merge-${{ github.event.pull_request.number || github.event.workflow_run.pull_requests[0].number || github.sha }}
  cancel-in-progress: true

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    # Run for main PRs; for workflow_run events we'll resolve PR and skip if needed
    if: >
      (github.event_name == 'pull_request_target' && github.event.pull_request.base.ref == 'main')
      || (github.event_name == 'workflow_run')

    steps:
      - name: Get PR details
        id: get_pr
        uses: actions/github-script@v8
        with:
          script: |
            let pr;

            if (github.event_name === 'pull_request_target') {
              pr = github.event.pull_request;
            } else if (github.event_name === 'workflow_run') {
              // Find PR for completed workflow run
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`,
                per_page: 100
              });
              pr = prs.data.find(p => p.head.sha === context.payload.workflow_run.head_sha);
            }

            if (!pr) {
              core.info('No PR found for this event');
              core.setOutput('skip', 'true');
              return { skip: true };
            }

            if (pr.base.ref !== 'main') {
              core.info('PR is not targeting main branch, skipping');
              core.setOutput('skip', 'true');
              return { skip: true };
            }

            core.info(`Found PR #${pr.number}: ${pr.title}`);
            core.setOutput('skip', 'false');
            return {
              skip: false,
              number: pr.number,
              title: pr.title,
              author: pr.user.login,
              draft: pr.draft,
              mergeable_state: pr.mergeable_state,
              head_sha: pr.head.sha,
              head_ref: pr.head.ref,
              base_ref: pr.base.ref,
              labels: pr.labels.map(l => l.name),
              auto_merge: pr.auto_merge !== null
            };

      - name: Set wait pattern
        id: set_wait
        if: steps.get_pr.outputs.skip != 'true'
        uses: actions/github-script@v8
        with:
          script: |
            // Fast checks for all PRs to main (trunk-based development)
            const re = '^(ci-fast)$';
            core.setOutput('check_re', re);

      - name: Check if PR should be auto-merged
        id: should_merge
        if: steps.get_pr.outputs.skip != 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            const labels = new Set(pr.labels || []);
            const author = pr.author || '';

            // Skip conditions
            const skipReasons = [];

            if (pr.draft) {
              skipReasons.push('PR is draft');
            }

            if (labels.has('blocked')) {
              skipReasons.push('blocked label');
            }

            if (labels.has('human-review')) {
              skipReasons.push('human-review label');
            }

            if (labels.has('no-auto-merge')) {
              skipReasons.push('no-auto-merge label');
            }

            if (labels.has('claude:needs-fixes')) {
              skipReasons.push('claude:needs-fixes label');
            }

            if (labels.has('needs-human')) {
              skipReasons.push('needs-human label');
            }

            // AI automation labels (block while AI is working)
            if (labels.has('ai:fixing')) {
              skipReasons.push('ai:fixing label - AI auto-fix in progress');
            }

            if (labels.has('ci:healing')) {
              skipReasons.push('ci:healing label - CI auto-heal in progress');
            }

            if (skipReasons.length > 0) {
              core.info(`Skipping auto-merge: ${skipReasons.join(', ')}`);
              return { should_merge: false, reason: skipReasons.join(', ') };
            }

            // Determine PR type and eligibility
            let prType = 'regular';
            let eligible = false;

            if (pr.author === 'dependabot[bot]') {
              prType = 'dependabot';
              // For dependabot, check if it's patch/minor or security update
              eligible = true; // We'll validate update type in next step
            } else if (labels.has('codegen') || author === 'app/codegen-sh' || author === 'codegen-sh[bot]' || author.includes('codegen')) {
              prType = 'codegen';
              eligible = true;
            } else {
              prType = 'regular';
              // For regular PRs, only auto-merge if they have specific labels or conditions
              eligible = labels.has('auto-merge') || labels.has('dependencies');
            }

            core.info(`PR type: ${prType}, eligible: ${eligible}`);
            return { 
              should_merge: eligible, 
              pr_type: prType,
              reason: eligible ? `${prType} PR eligible for auto-merge` : `${prType} PR not eligible`
            };

      - name: Validate Dependabot update type
        id: validate_dependabot
        if: steps.should_merge.outputs.should_merge == 'true' && fromJSON(steps.should_merge.outputs.result).pr_type == 'dependabot'
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check Dependabot eligibility
        id: dependabot_check
        if: steps.validate_dependabot.outcome == 'success'
        run: |
          update_type="${{ steps.validate_dependabot.outputs.update-type }}"
          dependency_type="${{ steps.validate_dependabot.outputs.dependency-type }}"

          # Allow security updates
          if [[ "$dependency_type" == "direct:security" ]]; then
            echo "allowed=true" >> $GITHUB_OUTPUT
            echo "reason=Security update" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Allow patch and minor updates
          if [[ "$update_type" =~ ^version-update:semver-(patch|minor)$ ]]; then
            echo "allowed=true" >> $GITHUB_OUTPUT
            echo "reason=Safe ${update_type#version-update:semver-} update" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "allowed=false" >> $GITHUB_OUTPUT
          echo "reason=Major version update requires human review" >> $GITHUB_OUTPUT

      - name: Wait for required CI checks
        id: wait_for_ci
        if: steps.should_merge.outputs.should_merge == 'true' && (steps.dependabot_check.outputs.allowed != 'false')
        uses: lewagon/wait-on-check-action@v1.4.1
        continue-on-error: true
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 15
          # Wait for all required checks from ruleset
          check-regexp: ${{ steps.set_wait.outputs.check_re }}
          allowed-conclusions: success,skipped
          timeout-minutes: 5

      - name: Check if branch needs updating
        id: check_branch_status
        if: steps.wait_for_ci.outputs.status == 'success' || steps.wait_for_ci.outcome == 'failure'
        uses: actions/github-script@v8
        with:
          result-encoding: string
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');

            try {
              // Get PR details to check mergeable state
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });

              core.info(`PR mergeable: ${prData.mergeable}, mergeable_state: ${prData.mergeable_state}`);

              // Check if branch is behind
              const needsUpdate = prData.mergeable_state === 'behind' || prData.mergeable_state === 'dirty';

              // Set outputs directly instead of returning object
              core.setOutput('needs_update', needsUpdate ? 'true' : 'false');
              core.setOutput('mergeable', prData.mergeable !== null ? String(prData.mergeable) : 'null');
              core.setOutput('mergeable_state', prData.mergeable_state || 'unknown');

              return JSON.stringify({
                needs_update: needsUpdate,
                mergeable: prData.mergeable,
                mergeable_state: prData.mergeable_state
              });
            } catch (error) {
              core.warning(`Error checking branch status: ${error.message}`);
              core.setOutput('needs_update', 'false');
              core.setOutput('mergeable', 'null');
              core.setOutput('mergeable_state', 'unknown');
              return JSON.stringify({ needs_update: false, mergeable: null, mergeable_state: 'unknown' });
            }

      - name: Update branch if needed
        id: update_branch
        if: steps.check_branch_status.outputs.needs_update == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');

            try {
              core.info(`Updating branch for PR #${pr.number}`);
              
              await github.rest.pulls.updateBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              core.info('Branch update requested successfully');
              
              // Wait a moment for update to process
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              return { updated: true };
            } catch (error) {
              core.warning(`Failed to update branch: ${error.message}`);
              return { updated: false, error: error.message };
            }

      - name: Mark PR ready for review
        id: mark_ready
        if: steps.wait_for_ci.outputs.status == 'success' || steps.wait_for_ci.outcome == 'failure'
        uses: actions/github-script@v8
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');

            if (pr.draft) {
              try {
                await github.graphql(
                  `mutation($id: ID!) { 
                    markPullRequestReadyForReview(input: { pullRequestId: $id }) { 
                      clientMutationId 
                    } 
                  }`,
                  { id: await github.rest.pulls.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number
                    }).then(r => r.data.node_id) }
                );
                core.info(`Marked PR #${pr.number} ready for review`);
                return { marked_ready: true };
              } catch (error) {
                core.warning(`Failed to mark PR ready: ${error.message}`);
                return { marked_ready: false, error: error.message };
              }
            }

            return { marked_ready: false, reason: 'PR already ready' };

      - name: Enable auto-merge
        id: enable_automerge
        if: steps.wait_for_ci.outputs.status == 'success' || steps.wait_for_ci.outcome == 'failure'
        uses: actions/github-script@v8
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');

            // If auto-merge is already enabled, skip
            if (pr.auto_merge) {
              core.info(`Auto-merge already enabled for PR #${pr.number}`);
              return { enabled: false, reason: 'Already enabled' };
            }

            try {
              // Get current PR node_id
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              await github.graphql(
                `mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: { 
                    pullRequestId: $pullRequestId, 
                    mergeMethod: $mergeMethod 
                  }) {
                    pullRequest { number, autoMergeRequest { enabledAt } }
                  }
                }`,
                { 
                  pullRequestId: prData.node_id, 
                  mergeMethod: 'SQUASH' 
                }
              );
              
              core.info(`✅ Auto-merge enabled for PR #${pr.number} (squash method)`);
              return { enabled: true };
              
            } catch (error) {
              core.warning(`❌ Failed to enable auto-merge: ${error.message}`);
              return { enabled: false, error: error.message };
            }

      - name: Summary
        if: always() && steps.get_pr.outputs.skip != 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            const shouldMerge = '${{ steps.should_merge.outputs.should_merge }}';
            const waitStatus = '${{ steps.wait_for_ci.outputs.status }}';
            const autoMergeEnabled = '${{ steps.enable_automerge.outputs.enabled }}';

            let summary = `## Auto-merge Summary for PR #${pr.number}\n\n`;

            if (shouldMerge !== 'true') {
              const resultStr = '${{ steps.should_merge.outputs.result }}';
              const parsed = resultStr && resultStr !== '{}' ? JSON.parse(resultStr) : {};
              const reason = parsed.reason || 'Unknown';
              summary += `❌ **Skipped**: ${reason}\n`;
            } else if (waitStatus !== 'success') {
              summary += `⏳ **Waiting**: CI checks still running or failed\n`;
            } else if (autoMergeEnabled === 'true') {
              summary += `✅ **Success**: Auto-merge enabled, PR will merge when all checks pass\n`;
            } else {
              summary += `⚠️ **Partial**: CI passed but auto-merge could not be enabled\n`;
            }

            const parsed = (() => {
              const resultStr = '${{ steps.should_merge.outputs.result }}';
              return resultStr && resultStr !== '{}' ? JSON.parse(resultStr) : {};
            })();

            const labels = Array.isArray(pr.labels) ? pr.labels : [];
            summary += `\n**PR Type**: ${parsed.pr_type || 'unknown'}`;
            summary += `\n**Labels**: ${labels.join(', ') || 'none'}`;

            core.info(summary);
