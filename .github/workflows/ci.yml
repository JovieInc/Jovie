name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main, 'codegen-bot/**']
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
  workflow_dispatch:

permissions: read-all

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:

  ci-env-example-guard:
    name: Env Example Guard
    # Always run; fast, prevents accidental secret commits.
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Validate .env.example contains placeholders only
        run: |
          set -euo pipefail

          if [ ! -f .env.example ]; then
            echo "No .env.example found; skipping."
            exit 0
          fi

          # Fail on common secret/token prefixes.
          if grep -nE '(sk_live_|sk_test_|rk_live_|rk_test_|whsec_|ghp_|github_pat_|xoxb-|BEGIN PRIVATE KEY|-----BEGIN)' .env.example; then
            echo "❌ .env.example appears to contain a real secret/token. Replace with placeholders."
            exit 1
          fi

          # Fail on real-looking Stripe price IDs (these should be placeholders).
          if grep -nE '^STRIPE_PRICE_.*=price_[A-Za-z0-9]+' .env.example; then
            echo "❌ .env.example contains Stripe price IDs. Replace with placeholders."
            exit 1
          fi

          echo "✅ .env.example looks safe (no obvious secrets)."

  ci-guardrails:
    name: Guardrails (proxy + format)
    # Draft PRs skip; ready PRs + pushes + merge queue enforce core repo guardrails
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping guardrails."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping guardrails."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Next.js proxy guard
        run: pnpm --filter=@jovie/web run next:proxy-guard
      - name: Format check (Biome)
        run: pnpm run format:check

  ci-typecheck:
    name: Typecheck
    # Draft PRs skip; ready PRs + pushes + merge queue run typecheck
    # Note: Runs in parallel with lint for speed (no dependency on cache-warm)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping typecheck."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping typecheck."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Cache Turbo
        uses: actions/cache@v5
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-
      - name: Cache TypeScript artifacts
        uses: actions/cache@v5
        with:
          path: |
            .cache/tsbuildinfo
            apps/web/.cache/tsbuildinfo
          key: ${{ runner.os }}-tsc-${{ github.ref }}-${{ hashFiles('**/tsconfig.json', '**/pnpm-lock.yaml', '**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-tsc-${{ github.ref }}-
            ${{ runner.os }}-tsc-
      - name: Run typecheck
        run: pnpm turbo typecheck --filter=@jovie/web
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_TEAM: ${{ vars.TURBO_TEAM }}

  ci-lint:
    name: Lint
    # Draft PRs skip; ready PRs + pushes + merge queue run lint
    # Note: Runs in parallel with typecheck for speed (no dependency on cache-warm)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping lint."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping lint."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Cache Turbo
        uses: actions/cache@v5
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-
      - name: Run lint
        run: pnpm turbo lint --filter=@jovie/web
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_TEAM: ${{ vars.TURBO_TEAM }}

  ci-cache-warm:
    name: Cache Warm (pnpm + Next build cache)
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping cache warm."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping cache warm."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Cache Turbo
        uses: actions/cache@v5
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-
      - name: Cache Next build cache
        uses: actions/cache@v5
        with:
          path: |
            apps/web/.next/cache
            .turbo
          key: ${{ runner.os }}-next-${{ hashFiles('**/pnpm-lock.yaml', '**/package.json') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-next-${{ hashFiles('**/pnpm-lock.yaml', '**/package.json') }}-
            ${{ runner.os }}-next-
          save-always: true
      - name: Warm Next build cache
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        run: pnpm turbo build --filter=@jovie/web
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_TEAM: ${{ vars.TURBO_TEAM }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN || 'https://placeholder.supabase.co' }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN || 'placeholder' }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN || 'placeholder' }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY || 'placeholder' }}
          NEXT_IGNORE_ESLINT: '1'
          NEXT_IGNORE_TYPECHECK: '1'
          NEXT_PRIVATE_SKIP_SIZE_CHECK: 'true'

  neon-db:
    name: Neon DB
    # Only run for push and PRs to production (or testing label)
    # Skip for merge queue and PRs to main to keep the fast lane truly fast
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false && (github.event.pull_request.base.ref == 'production' || contains(github.event.pull_request.labels.*.name, 'testing'))) }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      branch_name: ${{ steps.sanitize-branch.outputs.name }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - name: Check for backend changes
        id: check-backend
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          # Check if any backend-related files changed (migrations, lib/db, API routes, etc.)
          if echo "$CHANGED_FILES" | grep -E '^(drizzle/migrations/|apps/web/lib/db/|apps/web/app/api/)' > /dev/null; then
            echo "Backend changes detected, Neon DB required"
            echo "needs_db=true" >> $GITHUB_OUTPUT
          else
            echo "No backend changes detected, skipping Neon DB creation"
            echo "needs_db=false" >> $GITHUB_OUTPUT
            exit 0
          fi

      - name: Cleanup old Neon branches (prevent limit errors)
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        uses: ./.github/actions/neon-branch-cleanup
        with:
          neon_api_key: ${{ secrets.NEON_API_KEY }}
          neon_project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_limit: '10'
          protected_branches: 'main,production,br-main,br-production'
          cleanup_threshold: '7'

      - name: Determine sanitized branch name
        id: sanitize-branch
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        run: |
          RAW="${{ github.head_ref || github.ref_name }}"

          # Avoid collisions with protected long-lived branches in Neon.
          # For push to main/production we reuse the long-lived Neon branches.
          if [[ "${{ github.event_name }}" == "push" && ("${{ github.ref_name }}" == "main" || "${{ github.ref_name }}" == "production") ]]; then
            RAW="${{ github.ref_name }}"
          fi

          # sanitize: lowercase, replace slashes with dashes, remove invalid chars, collapse repeats
          SANITIZED=$(echo "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's|/|-|g; s|[^a-z0-9._-]|-|g; s/-{2,}/-/g; s/^-+//; s/-+$//')
          BASE=$(echo "$SANITIZED" | cut -c1-40)
          SUFFIX="${{ github.run_id }}-${{ github.run_attempt }}"
          FINAL="${BASE}-${SUFFIX}"
          echo "Using sanitized branch name: $FINAL"
          echo "name=$FINAL" >> $GITHUB_OUTPUT
      - name: Create or reuse Neon branch
        id: create-branch
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ steps.sanitize-branch.outputs.name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}
      - name: Finalize Neon DB URLs
        id: finalize-urls
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        run: |
          DB_URL="${{ steps.create-branch.outputs.db_url }}"
          DB_URL_POOLED="${{ steps.create-branch.outputs.db_url_pooled }}"

          if [ -z "$DB_URL" ]; then
            echo "Neon branch creation did not return db_url."
            echo "This indicates NEON_PROJECT_ID/NEON_API_KEY or the create-branch action is failing."
            exit 1
          fi

          # Intentionally do NOT expose DB_URL via job outputs.
          # GitHub will drop outputs that look like secrets, which breaks downstream jobs.
          echo "Neon DB URL resolved for this job."

  drizzle-migration-guard:
    name: Migration Guard
    # Skip if 'skip-migration-guard' label is present (for schema consolidation)
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && !contains(github.event.pull_request.labels.*.name, 'skip-migration-guard')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 3
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip notification (updated condition)
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping migration guard as no DB/schema paths were changed."
          exit 0
      - name: Run Migration Guard
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          # Make script executable
          chmod +x apps/web/scripts/check-migrations.sh
          chmod +x apps/web/scripts/validate-migrations.sh

          # Run migration guard and validation from apps/web directory
          cd apps/web
          ./scripts/check-migrations.sh
          ./scripts/validate-migrations.sh
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}

  ci-drizzle-check:
    name: Drizzle Check
    needs: [neon-db]  # Optimized: only needs DB, can run parallel with typecheck/lint
    # Drizzle check is NOT required for merge queue (main) - only run on push or PRs to production/testing
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && (github.event.pull_request.base.ref == 'production' || contains(github.event.pull_request.labels.*.name, 'testing'))) }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Check if Drizzle-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping Drizzle check as no DB/schema paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      - name: Resolve Neon DB URL (job-local)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: resolve_neon
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ needs.neon-db.outputs.branch_name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL (Neon ephemeral)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.resolve_neon.outputs.db_url }}"
          if [ -n "$CANDIDATE" ]; then
            echo "Using Neon DB URL from neon-db job outputs"
            echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV
          else
            echo "No Neon ephemeral DB URL available from neon-db job."
          fi

      - name: Fail if Neon DB URL is missing
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          if [[ -z "$DATABASE_URL" ]]; then
            echo "No Neon ephemeral DATABASE_URL available. Refusing to run Drizzle check against staging/production DBs."
            exit 1
          fi

      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Run Drizzle Check
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:check

  ci-fast:
    name: ci-fast
    # Gate for PRs, pushes, and merge queue: aggregate fast checks
    needs: [ci-typecheck, ci-lint, ci-guardrails]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: All fast checks passed
        run: |
          echo "ci-fast passed: Typecheck and Lint succeeded"

  ci-pr-neon-migrate:
    name: DB Migrate (PR main)
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    timeout-minutes: 12
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - name: Cleanup old Neon branches (prevent limit errors)
        uses: ./.github/actions/neon-branch-cleanup
        with:
          neon_api_key: ${{ secrets.NEON_API_KEY }}
          neon_project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_limit: '10'
          protected_branches: 'main,production,br-main,br-production'
          cleanup_threshold: '7'

      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event.pull_request.head.repo.fork }}

      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping DB migrate check: no DB/schema/migration paths were changed."
          exit 0

      - name: Determine sanitized Neon branch name
        id: sanitize-branch
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          RAW="${{ github.head_ref }}"
          SANITIZED=$(echo "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's|/|-|g; s|[^a-z0-9._-]|-|g; s/-{2,}/-/g; s/^-+//; s/-+$//')
          BASE=$(echo "$SANITIZED" | cut -c1-40)
          SUFFIX="${{ github.run_id }}-${{ github.run_attempt }}"
          FINAL="${BASE}-${SUFFIX}"
          echo "Using sanitized branch name: $FINAL"
          echo "name=$FINAL" >> $GITHUB_OUTPUT

      - name: Create or reuse Neon branch
        id: create-branch
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ steps.sanitize-branch.outputs.name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL (Neon ephemeral)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.create-branch.outputs.db_url }}"
          if [ -z "$CANDIDATE" ]; then
            echo "No Neon ephemeral DATABASE_URL available."
            exit 1
          fi
          echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV

      - uses: ./.github/actions/setup-node-pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'

      - name: Run migrations (ephemeral Neon)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:migrate
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NODE_ENV: test
          GIT_BRANCH: pr-${{ github.event.pull_request.number }}
          ALLOW_PROD_MIGRATIONS: 'true'

  # Public Profile Smoke Test - runs against main.jov.ie (staging) to verify public profiles work
  # This test runs on pushes to main after deploy completes
  ci-public-profile-smoke:
    name: Public Profile Smoke
    needs: [deploy]
    # Only run after successful deploy to main staging
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - uses: ./.github/actions/setup-node-pnpm

      - name: Cache Playwright Browsers
        uses: actions/cache@v5
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-chromium-${{ hashFiles('pnpm-lock.yaml', 'package.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-chromium-

      - name: Install Playwright (Chromium only)
        run: pnpm --filter=@jovie/web exec playwright install chromium --with-deps

      - name: Run Public Profile Smoke Test against staging
        run: |
          CI=true BASE_URL=https://main.jov.ie pnpm --filter=@jovie/web run test:e2e tests/e2e/public-profile-smoke.spec.ts --project=chromium --reporter=line
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Performance Budget Guard against staging
        run: |
          CI=true BASE_URL=https://main.jov.ie pnpm --filter=@jovie/web run test:budgets
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Upload Playwright Artifacts on Failure
        if: failure()
        uses: actions/upload-artifact@v6
        with:
          name: public-profile-smoke-report-${{ github.run_id }}
          path: |
            playwright-report/
            test-results/
          retention-days: 3

  ci-build:
    name: Build
    needs: [ci-fast]
    # Build is NOT required for merge queue (main) - only run on push or PRs to production/testing
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && (github.event.pull_request.base.ref == 'production' || contains(github.event.pull_request.labels.*.name, 'testing'))) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Path guard: Check if changes affect critical files (only for pushes and non-production PRs)
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'build'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping full CI as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Cache Next build cache
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: actions/cache@v5
        with:
          path: .next/cache
          key: ${{ runner.os }}-next-${{ hashFiles('pnpm-lock.yaml', 'package.json') }}
          restore-keys: |
            ${{ runner.os }}-next-

      - name: Build
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          NEXT_IGNORE_ESLINT: '1'
          NEXT_IGNORE_TYPECHECK: '1'
          NEXT_PRIVATE_SKIP_SIZE_CHECK: 'true'

  ci-unit-tests:
    name: Unit Tests
    needs: [ci-fast]
    # Unit tests are NOT required for merge queue (main) - only run on push or PRs to production/testing
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && (github.event.pull_request.base.ref == 'production' || contains(github.event.pull_request.labels.*.name, 'testing'))) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Check if test-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'test'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping unit tests as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Load quarantined unit tests
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: quarantine
        run: |
          FILE="apps/web/tests/quarantine.json"
          UNIT_FILES=""
          UNIT_EXCLUDES=""

          if [ -f "$FILE" ]; then
            UNIT_FILES=$(jq -r '.unit // [] | join(" ")' "$FILE")
            UNIT_EXCLUDES=$(jq -r '.unit // [] | map("--exclude=" + .) | join(" ")' "$FILE")
          fi

          echo "unit_files=$UNIT_FILES" >> $GITHUB_OUTPUT
          echo "unit_excludes=$UNIT_EXCLUDES" >> $GITHUB_OUTPUT

          if [ -n "$UNIT_FILES" ]; then
            echo "has_unit=true" >> $GITHUB_OUTPUT
          else
            echo "has_unit=false" >> $GITHUB_OUTPUT
          fi

      - name: Run unit tests
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run test -- ${{ steps.quarantine.outputs.unit_excludes }}
        env:
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}

      - name: Run quarantined unit tests (retries)
        if: steps.check_changes.outputs.run_full_ci == 'true' && steps.quarantine.outputs.has_unit == 'true'
        continue-on-error: true
        run: cd apps/web && pnpm vitest run --config=vitest.config.mts --retry=2 ${{ steps.quarantine.outputs.unit_files }}
        env:
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}

  ci-merge-smoke:
    name: Merge Group Smoke
    if: ${{ github.event_name == 'merge_group' }}
    needs: [ci-fast]
    runs-on: ubuntu-latest
    timeout-minutes: 7
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2
      - uses: ./.github/actions/setup-node-pnpm
      - name: Build (smoke)
        run: pnpm --filter=@jovie/web run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          NEXT_IGNORE_ESLINT: '1'
          NEXT_IGNORE_TYPECHECK: '1'
          NEXT_PRIVATE_SKIP_SIZE_CHECK: 'true'

  ci-e2e-tests:
    name: E2E Tests
    needs: [ci-build, neon-db]
    # E2E is NOT required for merge queue (main) - only run on push to main/production or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && (github.event.pull_request.base.ref == 'production' || contains(github.event.pull_request.labels.*.name, 'testing'))) }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Check if E2E-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'e2e'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping E2E tests as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Resolve Neon DB URL (job-local)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: resolve_neon
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ needs.neon-db.outputs.branch_name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL for E2E
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.resolve_neon.outputs.db_url }}"
          SRC=""
          if [ -n "$CANDIDATE" ]; then
            echo "Using Neon DB URL from neon-db job outputs"
            echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV
            SRC="neon-job-output"
          else
            echo "No Neon ephemeral DB URL available from neon-db job."
            SRC="unresolved"
          fi
          echo "RESOLVED_DB_SOURCE=$SRC" >> $GITHUB_ENV

      - name: Fail if Neon DB URL is missing (E2E)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          if [[ -z "$DATABASE_URL" ]]; then
            echo "No Neon ephemeral DATABASE_URL available. Refusing to run E2E against staging/production DBs."
            exit 1
          fi

      - name: Run migrations for E2E DB
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:migrate
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NODE_ENV: test
          GIT_BRANCH: ${{ github.ref_name }}
          ALLOW_PROD_MIGRATIONS: 'true'

      - name: Cache Playwright Browsers
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/cache@v5
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('pnpm-lock.yaml', 'package.json', 'playwright.config*.ts') }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: Install Playwright
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: pnpm --filter=@jovie/web exec playwright install chromium firefox --with-deps

      - name: Load quarantined E2E specs
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        id: quarantine
        run: |
          FILE="apps/web/tests/quarantine.json"
          QUARANTINED=()

          if [ -f "$FILE" ]; then
            mapfile -t QUARANTINED < <(jq -r '.e2e // [] | .[]' "$FILE")
          fi

          mapfile -t ALL_SPECS < <(git ls-files "apps/web/tests/e2e/**/*.spec.ts" "apps/web/tests/smoke/**/*.spec.ts")

          ALLOWED_SPECS=()
          for spec in "${ALL_SPECS[@]}"; do
            skip=false
            for quarantined in "${QUARANTINED[@]}"; do
              if [[ "$spec" == "$quarantined" ]]; then
                skip=true
                break
              fi
            done
            if [[ "$skip" == "false" ]]; then
              ALLOWED_SPECS+=("$spec")
            fi
          done

          echo "allowed_specs=${ALLOWED_SPECS[*]}" >> $GITHUB_OUTPUT
          echo "quarantined_specs=${QUARANTINED[*]}" >> $GITHUB_OUTPUT

          if [ ${#QUARANTINED[@]} -gt 0 ]; then
            echo "has_quarantine=true" >> $GITHUB_OUTPUT
          else
            echo "has_quarantine=false" >> $GITHUB_OUTPUT
          fi

      - name: E2E Smoke (PR to Preview)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && github.event_name == 'pull_request' && github.ref != 'refs/heads/production' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: |
          if [ -z "${{ steps.quarantine.outputs.allowed_specs }}" ]; then
            echo "No non-quarantined E2E specs to run."
            exit 0
          fi
          cd apps/web && pnpm playwright test -g @smoke --trace=retain-on-failure ${{ steps.quarantine.outputs.allowed_specs }}
        continue-on-error: ${{ github.event_name == 'pull_request' }}

      - name: E2E Full (Main Branch)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && github.ref == 'refs/heads/main' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: |
          if [ -z "${{ steps.quarantine.outputs.allowed_specs }}" ]; then
            echo "No non-quarantined E2E specs to run."
            exit 0
          fi
          cd apps/web && pnpm playwright test --reporter=line ${{ steps.quarantine.outputs.allowed_specs }}

      - name: E2E Quarantine (retries)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && steps.quarantine.outputs.has_quarantine == 'true' }}
        continue-on-error: true
        run: cd apps/web && pnpm playwright test --reporter=line --retries=2 ${{ steps.quarantine.outputs.quarantined_specs }}

      - name: Upload Playwright Report on Failure
        if: ${{ failure() && steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/upload-artifact@v6
        with:
          name: ${{ github.job }}-playwright-report-${{ github.run_id }}-${{ github.run_attempt }}
          path: apps/web/playwright-report/
          retention-days: 7

      - name: Upload Playwright Test Results on Failure
        if: ${{ failure() && steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/upload-artifact@v6
        with:
          name: ${{ github.job }}-test-results-${{ github.run_id }}-${{ github.run_attempt }}
          path: apps/web/test-results/
          retention-days: 7

  ci-pr-vercel-preview:
    name: Preview Deploy (PR)
    # Only needs build - no DB dependencies for fast UI-only PRs
    needs: [ci-build]
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      deployment_url: ${{ steps.pr_deploy.outputs.deployment_url }}
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-node@v5
        with:
          node-version: 20
          package-manager-cache: false
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: Pull env (preview)
        run: vercel pull --yes --environment=preview --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build (PR preview)
        run: vercel build --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
      - name: Deploy (PR preview, fast deployment for UI-only changes)
        id: pr_deploy
        run: |
          # For fast preview PRs: use main secrets (no Neon dependency)
          # Fallback hierarchy for maximum compatibility
          POOLED_URL=""
          if [ -n "$DATABASE_URL_MAIN" ]; then
            POOLED_URL="$DATABASE_URL_MAIN"
            echo "Using main database URL"
          elif [ -n "$DATABASE_URL" ]; then
            POOLED_URL="$DATABASE_URL"
            echo "Using fallback database URL"
          else
            # Provide cheap stub for UI-only deployments that might not need DB
            POOLED_URL="postgresql://stub:stub@localhost:5432/main_stub"
            echo "Using stub database URL for UI-only deployment"
          fi

          # Deploy preview with DATABASE_URL injected only for this deployment
          deployment_url=$(vercel deploy --prebuilt \
            --env DATABASE_URL="$POOLED_URL" \
            --env GIT_BRANCH="${GIT_BRANCH}" \
            --token $VERCEL_TOKEN)

          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          # Use main secrets - no Neon dependency for fast deployments
          DATABASE_URL_MAIN: ${{ secrets.DATABASE_URL_MAIN }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GIT_BRANCH: ${{ github.head_ref || github.ref_name }}

  ci-summary:
    name: CI Summary
    if: ${{ always() && github.event_name == 'pull_request' }}
    needs:
      - ci-env-example-guard
      - ci-guardrails
      - ci-typecheck
      - ci-lint
      - neon-db
      - drizzle-migration-guard
      - ci-drizzle-check
      - ci-fast
      - ci-pr-neon-migrate
      - ci-build
      - ci-unit-tests
      - ci-e2e-tests
      - ci-pr-vercel-preview
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      actions: read
      pull-requests: write
      contents: read
    steps:
      - name: Post CI summary to PR
        uses: actions/github-script@v8
        env:
          BUILD_RUN_FULL_CI: ${{ needs.ci-build.outputs.run_full_ci }}
          DRIZZLE_RUN_FULL_CI: ${{ needs.ci-drizzle-check.outputs.run_full_ci }}
          E2E_RUN_FULL_CI: ${{ needs.ci-e2e-tests.outputs.run_full_ci }}
          MIGRATION_GUARD_RUN_FULL_CI: ${{ needs.drizzle-migration-guard.outputs.run_full_ci }}
          PR_MIGRATE_RUN_FULL_CI: ${{ needs.ci-pr-neon-migrate.outputs.run_full_ci }}
          UNIT_RUN_FULL_CI: ${{ needs.ci-unit-tests.outputs.run_full_ci }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const runId = context.runId;

            const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id: runId,
              per_page: 100
            });

            const jobByName = new Map(
              jobsResponse.data.jobs.map(job => [job.name, job])
            );

            const formatDuration = (job) => {
              if (!job?.started_at || !job?.completed_at) return '—';
              const start = new Date(job.started_at);
              const end = new Date(job.completed_at);
              const ms = Math.max(0, end - start);
              const minutes = Math.floor(ms / 60000);
              const seconds = Math.floor((ms % 60000) / 1000);
              return minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            };

            const resolveOutcome = (jobName, fallbackResult) => {
              const job = jobByName.get(jobName);
              if (!job) return { status: fallbackResult ?? 'not_run', duration: '—' };
              return {
                status: job.conclusion || job.status || fallbackResult || 'unknown',
                duration: formatDuration(job)
              };
            };

            const summarizeStatus = (status) => {
              switch (status) {
                case 'success':
                  return '✅ Passed';
                case 'failure':
                  return '❌ Failed';
                case 'cancelled':
                  return '⚠️ Cancelled';
                case 'skipped':
                  return '⚠️ Skipped';
                case 'timed_out':
                  return '❌ Timed out';
                case 'not_run':
                  return '⚪️ Not run';
                default:
                  return `⚪️ ${status}`;
              }
            };

            const deriveSkipReason = (jobKey, runFullCiFlag) => {
              if (runFullCiFlag === 'false') {
                return 'Skipped (path guard: no relevant changes)';
              }
              if (runFullCiFlag === '') {
                return 'Skipped (job not applicable)';
              }
              return jobKey === 'neon-db'
                ? 'Skipped (not required for this PR)'
                : 'Skipped (conditional job)';
            };

            const summaryRows = [
              { label: 'Env Example Guard', jobName: 'Env Example Guard' },
              { label: 'Guardrails', jobName: 'Guardrails (proxy + format)' },
              { label: 'Fast Checks', jobName: 'Fast checks (typecheck + lint)' },
              {
                label: 'Migration Guard',
                jobName: 'Migration Guard',
                runFullCi: process.env.MIGRATION_GUARD_RUN_FULL_CI
              },
              { label: 'Neon DB', jobName: 'Neon DB' },
              {
                label: 'Drizzle Check',
                jobName: 'Drizzle Check',
                runFullCi: process.env.DRIZZLE_RUN_FULL_CI
              },
              {
                label: 'Build',
                jobName: 'Build',
                runFullCi: process.env.BUILD_RUN_FULL_CI
              },
              {
                label: 'Unit Tests',
                jobName: 'Unit Tests',
                runFullCi: process.env.UNIT_RUN_FULL_CI
              },
              {
                label: 'E2E Tests',
                jobName: 'E2E Tests',
                runFullCi: process.env.E2E_RUN_FULL_CI
              },
              {
                label: 'DB Migrate (PR main)',
                jobName: 'DB Migrate (PR main)',
                runFullCi: process.env.PR_MIGRATE_RUN_FULL_CI
              },
              { label: 'Preview Deploy', jobName: 'Preview Deploy (PR)' }
            ];

            const rows = summaryRows.map((row) => {
              const outcome = resolveOutcome(row.jobName);
              const statusLabel = summarizeStatus(outcome.status);
              const timing = outcome.duration;
              let context = 'Executed';
              if (outcome.status === 'skipped' || outcome.status === 'not_run') {
                context = deriveSkipReason(row.label, row.runFullCi ?? '');
              }
              return `| ${row.label} | ${statusLabel} | ${context} | ${timing} |`;
            });

            const summaryBody = [
              '## CI Summary',
              '',
              'A crisp snapshot of this PR run — executed vs. skipped, with timing for every key lane.',
              '',
              '| Job | Status | Context | Time |',
              '| --- | ------ | ------- | ---- |',
              ...rows,
              '',
              `**Run:** [${runId}](${context.serverUrl}/${owner}/${repo}/actions/runs/${runId})`,
              ''
            ].join('\n');

            const existingComments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber
            });

            const botComment = existingComments.data.find(comment =>
              comment.user?.type === 'Bot' && comment.body?.startsWith('## CI Summary')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: summaryBody
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: summaryBody
              });
            }
  deploy:
    needs: [ci-fast, ci-build, ci-unit-tests, ci-e2e-tests] # Requires all CI jobs to pass before main deploy
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    env:
      # Main/staging must always use DATABASE_URL_MAIN; keep production secrets separate.
      DATABASE_URL_MAIN: ${{ secrets.DATABASE_URL_MAIN }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
    environment:
      name: Main Staging
      url: https://main.jov.ie
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: DB safety check (main - preflight)
        run: pnpm --filter=@jovie/web run drizzle:migrate:preflight
        env:
          DATABASE_URL: ${{ env.DATABASE_URL_MAIN }}
          GIT_BRANCH: main
      - name: DB migrate (main - Drizzle)
        run: pnpm --filter=@jovie/web run drizzle:migrate
        env:
          DATABASE_URL: ${{ env.DATABASE_URL_MAIN }}
          GIT_BRANCH: main
          ALLOW_PROD_MIGRATIONS: 'true'  # Allow automated migrations on main (staging environment)
      - name: DB seed (main)
        run: pnpm --filter=@jovie/web run db:seed
        env:
          DATABASE_URL: ${{ env.DATABASE_URL_MAIN }}
          GIT_BRANCH: main
          ALLOW_DB_SEED: '1'
        continue-on-error: false
      - name: Pull env (main)
        run: vercel pull --yes --environment=preview --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build
        run: vercel build --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
      - name: Deploy (prebuilt)
        id: deploy
        run: |
          deployment_url=$(vercel deploy --prebuilt --token ${{ secrets.VERCEL_TOKEN }})
          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  canary-health-gate:
    name: Canary Health Gate (staging)
    needs: [deploy]
    if: ${{ needs.deploy.result == 'success' }}
    uses: ./.github/workflows/canary-health-gate.yml
    with:
      deployment_url: ${{ needs.deploy.outputs.deployment_url }}
      fallback_health_url: https://main.jov.ie/api/health
    secrets:
      VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

  staging-deploy-notify:
    name: Notify staging deploy
    needs: [deploy, canary-health-gate]
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve failure provenance
        id: failure-provenance
        if: ${{ always() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          api_url="${{ github.api_url }}/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs?per_page=100"
          response=$(curl -sS -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "$api_url")
          job_url=$(RESPONSE="$response" JOB_NAME="${{ github.job }}" python - <<'PY'
          import json
          import os

          data = json.loads(os.environ["RESPONSE"])
          job_name = os.environ["JOB_NAME"]
          job = next((item for item in data.get("jobs", []) if item.get("name") == job_name), None)
          print(job.get("html_url", "") if job else "")
          PY
          )

          if [ -z "$job_url" ]; then
            job_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}?check_suite_focus=true"
          fi

          echo "job_name=${{ github.job }}" >> "$GITHUB_OUTPUT"
          echo "job_url=$job_url" >> "$GITHUB_OUTPUT"

      - name: Slack notify (staging deploy)
        if: ${{ needs.deploy.result == 'success' && needs.canary-health-gate.result == 'success' && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#monitoring'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "✅ Staging deployed: main.jov.ie",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Workflow", "value": "CI", "short": true },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack notify (staging deploy failed)
        if: ${{ (needs.deploy.result != 'success' || needs.canary-health-gate.result != 'success') && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-production'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "🚨 Staging deploy failed: main.jov.ie",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Failing job", "value": "${{ steps.failure-provenance.outputs.job_name }}", "short": true },
                    { "title": "Failing job URL", "value": "<${{ steps.failure-provenance.outputs.job_url }}|View job>", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ============================================================================
  # FAST LANE / GATED LANE SYSTEM
  # ============================================================================
  # Fast Lane: Opt-in auto-promotion to production for low-risk changes
  # Gated Lane: Default - requires manual promotion for high-risk changes
  # See agents.md section 5.6 for full documentation
  # ============================================================================

  fastlane-eligibility:
    name: Fast Lane Eligibility
    needs: [drizzle-migration-guard]
    # Only run on push to main (staging deploy flow)
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      eligible: ${{ steps.check.outputs.eligible }}
      blockers: ${{ steps.check.outputs.blockers }}
      has_statsig_gate: ${{ steps.check.outputs.has_statsig_gate }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check fast lane eligibility
        id: check
        uses: ./.github/actions/fastlane-eligibility

      # Note: Label application moved to promote job to avoid race condition
      # The promote job creates/updates the PR first, then applies labels

  smoke-failure-alert:
    name: Smoke Failure Alert
    needs: [ci-public-profile-smoke, promote]
    # Alert when smoke tests fail after staging deploy
    # Depends on promote to ensure PR exists before trying to add labels
    if: ${{ always() && needs.ci-public-profile-smoke.result == 'failure' && github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      pull-requests: write
    steps:
      - name: Block promotion PR with smoke-failed label
        uses: actions/github-script@v8
        with:
          script: |
            // Find the promotion PR
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:main`,
              base: 'production'
            });

            if (prs.length > 0) {
              const pr = prs[0];
              core.info(`Blocking promotion PR #${pr.number} due to smoke test failure`);

              // Add blocking label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['blocked:smoke-failed']
              });

              // Add comment explaining the block
              const commentBody = [
                '## Smoke Tests Failed',
                '',
                'Staging smoke tests failed after deploy to main.jov.ie. Production promotion is **blocked**.',
                '',
                '**Action Required:** Investigate and fix the smoke test failures before promoting to production.',
                '',
                `[View CI Run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
              ].join('\n');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: commentBody
              });
            }

      - name: Slack alert (smoke failure blocks production)
        if: ${{ env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-production'
          author_name: 'Smoke Test'
          custom_payload: |
            {
              "text": ":rotating_light: Staging smoke tests FAILED - Production promotion BLOCKED",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Environment", "value": "main.jov.ie (staging)", "short": true },
                    { "title": "Status", "value": "Production blocked", "short": true },
                    { "title": "Action", "value": "Investigate smoke test failures before promoting", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  canary-failure-alert:
    name: Canary Failure Alert
    needs: [canary-health-gate, promote]
    # Alert when canary gate fails after staging deploy
    # Depends on promote to ensure PR exists before trying to add labels
    if: ${{ always() && needs.canary-health-gate.result == 'failure' && github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      pull-requests: write
    steps:
      - name: Block promotion PR with canary-failed label
        uses: actions/github-script@v8
        with:
          script: |
            // Find the promotion PR
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:main`,
              base: 'production'
            });

            if (prs.length > 0) {
              const pr = prs[0];
              core.info(`Blocking promotion PR #${pr.number} due to canary gate failure`);

              // Add blocking label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['blocked:canary-failed']
              });

              // Add comment explaining the block
              const commentBody = [
                '## Canary Health Gate Failed',
                '',
                'The canary health gate failed after deploy to main.jov.ie. Production promotion is **blocked**.',
                '',
                '**Action Required:** Investigate the health check failures before promoting to production.',
                '',
                `[View CI Run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
              ].join('\n');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: commentBody
              });
            }

      - name: Slack alert (canary failure blocks production)
        if: ${{ env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-production'
          author_name: 'Canary Gate'
          custom_payload: |
            {
              "text": ":rotating_light: Canary health gate FAILED - Production promotion BLOCKED",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Environment", "value": "main.jov.ie (staging)", "short": true },
                    { "title": "Status", "value": "Production blocked", "short": true },
                    { "title": "Action", "value": "Investigate health check failures before promoting", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  promote:
    name: Promote to Production
    # Supports both Fast Lane (auto-promote) and Gated Lane (manual review)
    # Fast Lane: Auto-enables auto-merge if 'fastlane' label + no blockers + smoke passed
    # Gated Lane: Creates/updates PR with QA checklist for manual review
    needs: [canary-health-gate, ci-public-profile-smoke, fastlane-eligibility]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
      pull-requests: write
    outputs:
      pr_number: ${{ steps.create-pr.outputs.pr_number }}
      promotion_type: ${{ steps.determine-path.outputs.promotion_type }}
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 2 }

      - name: Determine promotion path (Fast Lane vs Gated)
        id: determine-path
        uses: actions/github-script@v8
        with:
          script: |
            // Get eligibility from fastlane-eligibility job
            const eligible = '${{ needs.fastlane-eligibility.outputs.eligible }}' === 'true';
            const smokesPassed = '${{ needs.ci-public-profile-smoke.result }}' === 'success';
            const canaryPassed = '${{ needs.canary-health-gate.result }}' === 'success';

            core.info(`Fast lane eligibility: ${eligible}`);
            core.info(`Smoke tests passed: ${smokesPassed}`);
            core.info(`Canary gate passed: ${canaryPassed}`);

            // Find existing promotion PR
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:main`,
              base: 'production'
            });

            if (prs.length === 0) {
              core.info('No existing promotion PR - will create one');
              core.setOutput('action', 'create_pr');
              core.setOutput('promotion_type', 'gated');
              return;
            }

            const pr = prs[0];
            const labels = pr.labels.map(l => l.name);
            core.info(`Found promotion PR #${pr.number} with labels: ${labels.join(', ')}`);

            // Check for fast lane eligibility
            const hasFastlane = labels.includes('fastlane');
            const hasBlockers = labels.some(l => l.startsWith('blocked:'));
            const hasGated = labels.includes('gated');

            core.setOutput('pr_number', pr.number);

            if (hasFastlane && !hasBlockers && !hasGated && eligible && smokesPassed && canaryPassed) {
              core.info('FAST LANE: All conditions met - will enable auto-merge');
              core.setOutput('action', 'auto_merge');
              core.setOutput('promotion_type', 'fastlane');
            } else {
              // Log reason for gated lane
              const reason = hasBlockers ? `Blocking labels: ${labels.filter(l => l.startsWith('blocked:')).join(', ')}` :
                            hasGated ? 'Explicit gated label' :
                            !hasFastlane ? 'No fastlane label (opt-in required)' :
                            !eligible ? 'Path-based blocks detected' :
                            !smokesPassed ? 'Smoke tests failed' :
                            'Canary gate failed';
              core.info(`GATED LANE: ${reason}`);
              core.setOutput('action', 'update_pr');
              core.setOutput('promotion_type', 'gated');
              core.setOutput('gated_reason', reason);
            }

      - name: Create/Update promotion PR
        id: create-pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create PR body with QA checklist (using heredoc to avoid backtick issues)
          pr_body=$(cat <<'EOF'
          ## Release Promotion: main → production

          **Manual Review Required** (unless fast lane eligible)

          This PR promotes changes from **main** to **production** for production release.

          ### Fast Lane Eligibility
          Add the `fastlane` label if this PR:
          - Has NO database migrations
          - Has NO auth/Clerk changes
          - Has NO core flow changes (onboarding, subscribe)
          - Has NO payment changes
          - Is behind a feature flag OR is purely cosmetic/copy

          If any `blocked:*` labels are present, fast lane is not available.

          ### Pre-merge Checklist (Gated Lane)
          - [ ] **Full CI passed** (ci-full job completed successfully)
          - [ ] **CodeQL security scan passed** (if applicable)
          - [ ] **Preview environment tested** and verified working
          - [ ] **Database migrations reviewed** (if any)
          - [ ] **Feature flags configured** appropriately for production
          - [ ] **Monitoring/alerts reviewed** for new features
          - [ ] **Performance impact assessed** (no regressions)
          - [ ] **Rollback plan documented** (feature flags, DB, etc.)

          ### Release QA
          - [ ] **Smoke tests passed** in main environment
          - [ ] **Key user journeys verified** manually
          - [ ] **Mobile/responsive tested** (if UI changes)
          - [ ] **Cross-browser compatibility** verified (if applicable)
          - [ ] **Error handling tested** (edge cases, failures)

          ### Documentation
          - [ ] **CHANGELOG updated** with user-facing changes
          - [ ] **Feature documentation** updated (if applicable)
          - [ ] **API docs updated** (if API changes)

          **Do not merge until all checks pass and manual QA is complete (or use fast lane if eligible).**
          EOF
          )

          # Check if PR already exists
          existing_pr=$(gh pr list --head main --base production --json number --jq '.[0].number // empty')
          if [ -z "$existing_pr" ]; then
            echo "Creating new PR: main → production"
            new_pr=$(gh pr create --base production --head main --title "Release: Promote main to production" --body "$pr_body")
            pr_number=$(echo "$new_pr" | grep -oE '[0-9]+$' || gh pr list --head main --base production --json number --jq '.[0].number')
            echo "pr_number=$pr_number" >> $GITHUB_OUTPUT
          else
            echo "PR already exists: #$existing_pr"
            echo "pr_number=$existing_pr" >> $GITHUB_OUTPUT
          fi

      - name: Clean up stale blocking labels
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = parseInt('${{ steps.create-pr.outputs.pr_number }}');

            if (!prNumber) {
              core.info('No PR number available - skipping label cleanup');
              return;
            }

            const smokePassed = '${{ needs.ci-public-profile-smoke.result }}' === 'success';
            const canaryPassed = '${{ needs.canary-health-gate.result }}' === 'success';

            // Get current labels on PR
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const currentLabels = pr.labels.map(l => l.name);
            const labelsToRemove = [];

            // Remove smoke-failed label if smoke tests now pass
            if (smokePassed && currentLabels.includes('blocked:smoke-failed')) {
              labelsToRemove.push('blocked:smoke-failed');
            }

            // Remove canary-failed label if canary gate now passes
            if (canaryPassed && currentLabels.includes('blocked:canary-failed')) {
              labelsToRemove.push('blocked:canary-failed');
            }

            // Remove stale labels
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: label
                });
                core.info(`Removed stale label: ${label}`);
              } catch (error) {
                // Label might already be removed - that's OK
                if (error.status !== 404) {
                  core.warning(`Failed to remove label ${label}: ${error.message}`);
                }
              }
            }

            // Add comment if labels were removed
            if (labelsToRemove.length > 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: [
                  '## Blocking Labels Removed',
                  '',
                  'The following blocking labels have been removed because conditions have improved:',
                  labelsToRemove.map(l => `- \`${l}\``).join('\n'),
                  '',
                  'Re-evaluate fast lane eligibility for this PR.'
                ].join('\n')
              });
            }

      - name: Apply blocking labels to promotion PR
        uses: actions/github-script@v8
        with:
          script: |
            const blockers = JSON.parse('${{ needs.fastlane-eligibility.outputs.blockers }}' || '[]');
            const hasStatsigGate = '${{ needs.fastlane-eligibility.outputs.has_statsig_gate }}' === 'true';
            const prNumber = parseInt('${{ steps.create-pr.outputs.pr_number }}');

            if (!prNumber) {
              core.warning('No PR number available - skipping label application');
              return;
            }

            core.info(`Applying labels to PR #${prNumber}`);

            // Map blockers to labels
            const labelMap = {
              'migration': 'blocked:migration',
              'auth': 'blocked:auth',
              'core-flow': 'blocked:core-flow',
              'payments': 'blocked:payments'
            };

            // Build list of labels to add
            const labelsToAdd = blockers.map(b => labelMap[b]).filter(Boolean);

            // Add feature gate label if detected
            if (hasStatsigGate) {
              labelsToAdd.push('has-feature-gate');
            }

            if (labelsToAdd.length > 0) {
              core.info(`Adding labels: ${labelsToAdd.join(', ')}`);
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: labelsToAdd
                });
              } catch (error) {
                core.warning(`Failed to add labels: ${error.message}`);
              }
            }

            // Log eligibility status
            if (blockers.length === 0) {
              core.info('PR is ELIGIBLE for fast lane (no blocking patterns detected)');
            } else {
              core.info(`PR is NOT eligible for fast lane - blockers: ${blockers.join(', ')}`);
            }

      - name: Auto-apply fastlane label if eligible
        id: auto-fastlane
        if: steps.create-pr.outputs.pr_number
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = parseInt('${{ steps.create-pr.outputs.pr_number }}');
            const eligible = '${{ needs.fastlane-eligibility.outputs.eligible }}' === 'true';
            const smokePassed = '${{ needs.ci-public-profile-smoke.result }}' === 'success';
            const canaryPassed = '${{ needs.canary-health-gate.result }}' === 'success';

            if (!prNumber) {
              core.info('No PR number - skipping fastlane label');
              core.setOutput('applied', 'false');
              return;
            }

            // Get current labels
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const labels = pr.labels.map(l => l.name);
            const hasBlockers = labels.some(l => l.startsWith('blocked:'));
            const hasGated = labels.includes('gated');
            const hasFastlane = labels.includes('fastlane');

            // Skip if already has fastlane or explicitly gated
            if (hasFastlane) {
              core.info('PR already has fastlane label');
              core.setOutput('applied', 'false');
              return;
            }

            if (hasGated) {
              core.info('PR has explicit gated label - skipping fastlane');
              core.setOutput('applied', 'false');
              return;
            }

            // Auto-apply fastlane if all conditions met
            if (eligible && !hasBlockers && smokePassed && canaryPassed) {
              core.info('All conditions met - applying fastlane label and enabling auto-merge');

              // Apply the fastlane label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['fastlane']
              });

              // Enable auto-merge via GraphQL
              try {
                await github.graphql(`
                  mutation($pullRequestId: ID!) {
                    enablePullRequestAutoMerge(input: {
                      pullRequestId: $pullRequestId,
                      mergeMethod: SQUASH
                    }) {
                      pullRequest { number }
                    }
                  }
                `, { pullRequestId: pr.node_id });
                core.info(`Auto-merge enabled for PR #${prNumber}`);
              } catch (error) {
                core.warning(`Failed to enable auto-merge: ${error.message}`);
              }

              // Add comment explaining the auto-fastlane
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: [
                  '## 🚀 Fast Lane Auto-Enabled',
                  '',
                  'This PR has been automatically labeled for fast lane promotion:',
                  '- ✅ No blocking file patterns detected',
                  '- ✅ Smoke tests passed',
                  '- ✅ Canary health gate passed',
                  '',
                  'Auto-merge has been enabled. The PR will merge once all checks pass.',
                  '',
                  '_Add the `gated` label to require manual review instead._'
                ].join('\n')
              });

              core.setOutput('applied', 'true');
              core.setOutput('pr_number', prNumber.toString());
            } else {
              const reasons = [];
              if (!eligible) reasons.push('Blocking patterns detected');
              if (hasBlockers) reasons.push(`Has blocking labels: ${labels.filter(l => l.startsWith('blocked:')).join(', ')}`);
              if (!smokePassed) reasons.push('Smoke tests did not pass');
              if (!canaryPassed) reasons.push('Canary gate did not pass');
              core.info(`Fastlane not auto-applied: ${reasons.join(', ')}`);
              core.setOutput('applied', 'false');
            }

      - name: Fast lane auto-merge
        if: steps.determine-path.outputs.action == 'auto_merge'
        uses: actions/github-script@v8
        with:
          script: |
            const prNumber = parseInt('${{ steps.determine-path.outputs.pr_number }}');
            core.info(`Enabling auto-merge for fast lane PR #${prNumber}`);

            // Get PR details for GraphQL mutation
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            try {
              // Enable auto-merge via GraphQL
              await github.graphql(`
                mutation($pullRequestId: ID!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: SQUASH
                  }) {
                    pullRequest { number }
                  }
                }
              `, { pullRequestId: pr.node_id });

              core.info(`Fast lane: Auto-merge enabled for PR #${prNumber}`);

              // Add comment indicating fast lane promotion
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: [
                  '## Fast Lane Auto-Promotion',
                  '',
                  'This PR has been automatically queued for merge via **Fast Lane**.',
                  '',
                  '**Conditions met:**',
                  '- `fastlane` label present',
                  '- No blocking labels (`blocked:*`)',
                  '- Staging smoke tests passed',
                  '- Canary health gate passed',
                  '- No high-risk path changes detected',
                  '',
                  'The PR will merge automatically once all required checks pass.'
                ].join('\n')
              });
            } catch (error) {
              core.warning(`Failed to enable auto-merge: ${error.message}`);
              core.warning('PR may need manual merge or auto-merge may not be enabled for this repo');
            }

      - name: Notify fast lane promotion
        if: (steps.determine-path.outputs.action == 'auto_merge' || steps.auto-fastlane.outputs.applied == 'true') && env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#deployments'
          author_name: 'Fast Lane'
          custom_payload: |
            {
              "text": ":rocket: Fast Lane: Auto-promoting to production",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "Promotion Type", "value": "Fast Lane (automated)", "short": true },
                    { "title": "PR", "value": "#${{ steps.auto-fastlane.outputs.pr_number || steps.determine-path.outputs.pr_number }}", "short": true },
                    { "title": "Status", "value": "Auto-merge enabled, awaiting checks", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # NOTE: ai-review-gate job removed - was referencing deleted claude-code-review.yml
  # and non-existent copilot-pr-review.yml. CodeRabbit now handles AI reviews via .coderabbit.yaml

  deploy-prod:
    needs: [ci-fast, ci-build, ci-unit-tests, ci-e2e-tests]
    if: ${{ github.ref == 'refs/heads/production' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      # Production must always use DATABASE_URL; keep main/staging secrets separate.
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      DATABASE_URL_MAIN: ${{ secrets.DATABASE_URL_MAIN }}
    environment:
      name: Production
      url: https://jov.ie
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: DB safety check (production - preflight)
        run: pnpm --filter=@jovie/web run drizzle:migrate:preflight
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          GIT_BRANCH: production
          ALLOW_PROD_MIGRATIONS: 'true'
      - name: DB migrate (production) — requires backup and ALLOW_PROD_MIGRATIONS=true
        run: pnpm --filter=@jovie/web run drizzle:migrate:prod
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          GIT_BRANCH: production
          ALLOW_PROD_MIGRATIONS: true
        continue-on-error: false
      - name: Pull env (production)
        run: vercel pull --yes --environment=production --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build (production)
        run: vercel build --prod --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_PROD }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_PROD }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_PROD }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
      - name: Deploy (production, prebuilt)
        run: vercel deploy --prebuilt --prod --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Resolve failure provenance
        id: failure-provenance
        if: ${{ always() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          api_url="${{ github.api_url }}/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs?per_page=100"
          response=$(curl -sS -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "$api_url")
          job_url=$(RESPONSE="$response" JOB_NAME="${{ github.job }}" python - <<'PY'
          import json
          import os

          data = json.loads(os.environ["RESPONSE"])
          job_name = os.environ["JOB_NAME"]
          job = next((item for item in data.get("jobs", []) if item.get("name") == job_name), None)
          print(job.get("html_url", "") if job else "")
          PY
          )

          if [ -z "$job_url" ]; then
            job_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}?check_suite_focus=true"
          fi

          echo "job_name=${{ github.job }}" >> "$GITHUB_OUTPUT"
          echo "job_url=$job_url" >> "$GITHUB_OUTPUT"

      - name: Slack notify (production deploy)
        if: ${{ success() && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-production'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "✅ Production deployed: jov.ie",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "Branch", "value": "production", "short": true },
                    { "title": "Workflow", "value": "CI", "short": true },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack notify (production deploy failed)
        if: ${{ failure() && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-critical'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "🔥 Production deploy failed: jov.ie",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Branch", "value": "production", "short": true },
                    { "title": "Failing job", "value": "${{ steps.failure-provenance.outputs.job_name }}", "short": true },
                    { "title": "Failing job URL", "value": "<${{ steps.failure-provenance.outputs.job_url }}|View job>", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  lighthouse-ci-production:
    name: Lighthouse CI (Production)
    needs: [deploy-prod]
    if: ${{ github.ref == 'refs/heads/production' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch') }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/setup-node-pnpm
      - name: Run Lighthouse CI against production
        run: npx lhci autorun --config=.lighthouserc.json
