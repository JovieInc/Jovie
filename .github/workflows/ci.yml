name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main, 'codegen-bot/**']
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
  workflow_dispatch:

permissions:
  contents: read
  actions: read

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:

  ci-env-example-guard:
    name: Env Example Guard
    # Always run; fast, prevents accidental secret commits.
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with: { fetch-depth: 1 }
      - name: Validate .env.example contains placeholders only
        run: |
          set -euo pipefail

          if [ ! -f .env.example ]; then
            echo "No .env.example found; skipping."
            exit 0
          fi

          # Fail on common secret/token prefixes.
          if grep -nE '(sk_live_|sk_test_|rk_live_|rk_test_|whsec_|ghp_|github_pat_|xoxb-|BEGIN PRIVATE KEY|-----BEGIN)' .env.example; then
            echo "âŒ .env.example appears to contain a real secret/token. Replace with placeholders."
            exit 1
          fi

          # Fail on real-looking Stripe price IDs (these should be placeholders).
          if grep -nE '^STRIPE_PRICE_.*=price_[A-Za-z0-9]+' .env.example; then
            echo "âŒ .env.example contains Stripe price IDs. Replace with placeholders."
            exit 1
          fi

          echo "âœ… .env.example looks safe (no obvious secrets)."

  ci-guardrails:
    name: Guardrails (proxy)
    # Draft PRs skip; ready PRs + pushes + merge queue enforce core repo guardrails
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping guardrails."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping guardrails."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Next.js proxy guard
        run: pnpm --filter=@jovie/web run next:proxy-guard

  ci-biome:
    name: Lint
    # Single consolidated job for all Biome checks (lint + format)
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping Biome checks."
            exit 0
          fi

          # Skip for docs-only changes
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping Biome checks."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Run Biome CI (lint + format)
        run: |
          # For PRs: only lint changed files (faster, pre-commit already ran on local)
          # For pushes to main: full lint to catch any issues
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            git fetch origin "${{ github.base_ref }}" --depth=1
            # Use diff-filter=d to exclude deleted files (biome can't lint deleted files)
            # Include .mts/.mjs extensions for ESM config files
            CHANGED_FILES=$(git diff --diff-filter=d --name-only "origin/${{ github.base_ref }}" HEAD -- '*.ts' '*.tsx' '*.js' '*.jsx' '*.json' '*.mts' '*.mjs' | tr '\n' ' ')
            if [ -n "$CHANGED_FILES" ]; then
              echo "Linting changed files only: $CHANGED_FILES"
              pnpm biome ci --reporter=github $CHANGED_FILES
            else
              echo "No lintable files changed"
            fi
          else
            pnpm biome ci --reporter=github .
          fi

  ci-typecheck:
    name: Typecheck
    # Draft PRs skip; ready PRs + pushes + merge queue run typecheck
    # Note: Runs in parallel with lint for speed (no dependency on cache-warm)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping typecheck."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping typecheck."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Cache Turbo
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: .turbo
          # Use content hash for better cache hit rates (not commit SHA which changes every commit)
          key: ${{ runner.os }}-turbo-${{ hashFiles('turbo.json', '**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-turbo-
      - name: Cache TypeScript artifacts
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: |
            .cache/tsbuildinfo
            apps/web/.cache/tsbuildinfo
          key: ${{ runner.os }}-tsc-${{ github.ref }}-${{ hashFiles('**/tsconfig.json', '**/pnpm-lock.yaml', '**/package.json') }}
          restore-keys: |
            ${{ runner.os }}-tsc-${{ github.ref }}-
            ${{ runner.os }}-tsc-
      - name: Run typecheck
        run: pnpm turbo typecheck --filter=@jovie/web
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_TEAM: ${{ vars.TURBO_TEAM }}

  neon-db:
    name: Neon DB
    # Only run for push to main or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      branch_name: ${{ steps.sanitize-branch.outputs.name }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1

      - name: Check for backend changes
        id: check-backend
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          # Check if any backend-related files changed (migrations, lib/db, API routes, etc.)
          if echo "$CHANGED_FILES" | grep -E '^(drizzle/migrations/|apps/web/lib/db/|apps/web/app/api/)' > /dev/null; then
            echo "Backend changes detected, Neon DB required"
            echo "needs_db=true" >> $GITHUB_OUTPUT
          else
            echo "No backend changes detected, skipping Neon DB creation"
            echo "needs_db=false" >> $GITHUB_OUTPUT
            exit 0
          fi

      - name: Cleanup old Neon branches (prevent limit errors)
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        uses: ./.github/actions/neon-branch-cleanup
        with:
          neon_api_key: ${{ secrets.NEON_API_KEY }}
          neon_project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_limit: '10'
          protected_branches: 'main,br-main'
          cleanup_threshold: '7'

      - name: Determine sanitized branch name
        id: sanitize-branch
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        run: |
          RAW="${{ github.head_ref || github.ref_name }}"

          # Avoid collisions with protected long-lived branches in Neon.
          # For push to main we reuse the long-lived Neon branch.
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "main" ]]; then
            RAW="${{ github.ref_name }}"
          fi

          # sanitize: lowercase, replace slashes with dashes, remove invalid chars, collapse repeats
          SANITIZED=$(echo "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's|/|-|g; s|[^a-z0-9._-]|-|g; s/-{2,}/-/g; s/^-+//; s/-+$//')
          BASE=$(echo "$SANITIZED" | cut -c1-40)
          SUFFIX="${{ github.run_id }}-${{ github.run_attempt }}"
          FINAL="${BASE}-${SUFFIX}"
          echo "Using sanitized branch name: $FINAL"
          echo "name=$FINAL" >> $GITHUB_OUTPUT
      - name: Create or reuse Neon branch
        id: create-branch
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        uses: neondatabase/create-branch-action@72ed4f69a12b6be9c16aebfad893f6a21e9aba8b # v6.4.0
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ steps.sanitize-branch.outputs.name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}
      - name: Finalize Neon DB URLs
        id: finalize-urls
        if: ${{ github.event_name != 'pull_request' || steps.check-backend.outputs.needs_db == 'true' }}
        run: |
          DB_URL="${{ steps.create-branch.outputs.db_url }}"
          DB_URL_POOLED="${{ steps.create-branch.outputs.db_url_pooled }}"

          if [ -z "$DB_URL" ]; then
            echo "Neon branch creation did not return db_url."
            echo "This indicates NEON_PROJECT_ID/NEON_API_KEY or the create-branch action is failing."
            exit 1
          fi

          # Intentionally do NOT expose DB_URL via job outputs.
          # GitHub will drop outputs that look like secrets, which breaks downstream jobs.
          echo "Neon DB URL resolved for this job."

  drizzle-migration-guard:
    name: Migration Guard
    # Skip if 'skip-migration-guard' label is present (for schema consolidation)
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && !contains(github.event.pull_request.labels.*.name, 'skip-migration-guard')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 3
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip notification (updated condition)
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping migration guard as no DB/schema paths were changed."
          exit 0
      - name: Run Migration Guard
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          # Make script executable
          chmod +x apps/web/scripts/check-migrations.sh
          chmod +x apps/web/scripts/validate-migrations.sh

          # Run migration guard and validation from apps/web directory
          cd apps/web
          ./scripts/check-migrations.sh
          ./scripts/validate-migrations.sh
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}

  ci-drizzle-check:
    name: Drizzle Check
    needs: [neon-db]  # Optimized: only needs DB, can run parallel with typecheck/lint
    # Drizzle check runs on push to main or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      # Check if Drizzle-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping Drizzle check as no DB/schema paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      - name: Resolve Neon DB URL (job-local)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: resolve_neon
        uses: neondatabase/create-branch-action@72ed4f69a12b6be9c16aebfad893f6a21e9aba8b # v6.4.0
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ needs.neon-db.outputs.branch_name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL (Neon ephemeral)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.resolve_neon.outputs.db_url }}"
          if [ -n "$CANDIDATE" ]; then
            echo "Using Neon DB URL from neon-db job outputs"
            echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV
          else
            echo "No Neon ephemeral DB URL available from neon-db job."
          fi

      - name: Fail if Neon DB URL is missing
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          if [[ -z "$DATABASE_URL" ]]; then
            echo "No Neon ephemeral DATABASE_URL available. Refusing to run Drizzle check against staging/production DBs."
            exit 1
          fi

      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Run Drizzle Check
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:check

  ci-fast:
    name: ci-fast
    # Gate for PRs, pushes, and merge queue: aggregate fast checks
    needs: [ci-typecheck, ci-biome, ci-guardrails]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: All fast checks passed
        run: |
          echo "ci-fast passed: Typecheck, Biome (lint + format), and guardrails succeeded"

  ci-pr-neon-migrate:
    name: DB Migrate (PR main)
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    timeout-minutes: 12
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      - name: Cleanup old Neon branches (prevent limit errors)
        uses: ./.github/actions/neon-branch-cleanup
        with:
          neon_api_key: ${{ secrets.NEON_API_KEY }}
          neon_project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_limit: '10'
          protected_branches: 'main,br-main'
          cleanup_threshold: '7'

      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event.pull_request.head.repo.fork }}

      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping DB migrate check: no DB/schema/migration paths were changed."
          exit 0

      - name: Determine sanitized Neon branch name
        id: sanitize-branch
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          RAW="${{ github.head_ref }}"
          SANITIZED=$(echo "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's|/|-|g; s|[^a-z0-9._-]|-|g; s/-{2,}/-/g; s/^-+//; s/-+$//')
          BASE=$(echo "$SANITIZED" | cut -c1-40)
          SUFFIX="${{ github.run_id }}-${{ github.run_attempt }}"
          FINAL="${BASE}-${SUFFIX}"
          echo "Using sanitized branch name: $FINAL"
          echo "name=$FINAL" >> $GITHUB_OUTPUT

      - name: Create or reuse Neon branch
        id: create-branch
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: neondatabase/create-branch-action@72ed4f69a12b6be9c16aebfad893f6a21e9aba8b # v6.4.0
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ steps.sanitize-branch.outputs.name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL (Neon ephemeral)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.create-branch.outputs.db_url }}"
          if [ -z "$CANDIDATE" ]; then
            echo "No Neon ephemeral DATABASE_URL available."
            exit 1
          fi
          echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV

      - uses: ./.github/actions/setup-node-pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'

      - name: Run migrations (ephemeral Neon)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:migrate:ci
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NODE_ENV: test
          GIT_BRANCH: pr-${{ github.event.pull_request.number }}
          ALLOW_PROD_MIGRATIONS: 'true'

  # Public Profile Smoke Test - runs against jov.ie (production) to verify public profiles work
  # This test runs on pushes to main after deploy completes
  ci-public-profile-smoke:
    name: Public Profile Smoke
    needs: [deploy]
    # Only run after successful deploy to main (production)
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1

      - uses: ./.github/actions/setup-node-pnpm

      - name: Cache Playwright Browsers
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-chromium-${{ hashFiles('pnpm-lock.yaml', 'package.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-chromium-

      - name: Install Playwright (Chromium only)
        run: pnpm --filter=@jovie/web exec playwright install chromium --with-deps

      - name: Run Public Profile Smoke Test against production
        run: |
          CI=true BASE_URL=https://jov.ie pnpm --filter=@jovie/web run test:e2e tests/e2e/public-profile-smoke.spec.ts --project=chromium --reporter=line
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Performance Budget Guard against production
        run: |
          CI=true BASE_URL=https://jov.ie pnpm --filter=@jovie/web run test:budgets
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Upload Playwright Artifacts on Failure
        if: failure()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: public-profile-smoke-report-${{ github.run_id }}
          path: |
            playwright-report/
            test-results/
          retention-days: 3

  ci-build:
    name: Build
    # Optimized: only wait for typecheck, lint can run in parallel (doesn't affect build output)
    needs: [ci-typecheck]
    # Build runs on push to main or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      # Path guard: Check if changes affect critical files (only for pushes and non-production PRs)
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'build'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping full CI as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Cache Next build cache
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: .next/cache
          key: ${{ runner.os }}-next-${{ hashFiles('pnpm-lock.yaml', 'package.json') }}
          restore-keys: |
            ${{ runner.os }}-next-

      - name: Build
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run build
        env:
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          NEXT_IGNORE_ESLINT: '1'
          NEXT_IGNORE_TYPECHECK: '1'
          NEXT_PRIVATE_SKIP_SIZE_CHECK: 'true'

      - name: Pre-deploy Lighthouse performance check
        if: steps.check_changes.outputs.run_full_ci == 'true' && github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          cd apps/web

          # Start Next.js server in background
          pnpm start &
          SERVER_PID=$!

          # Wait for server to be ready
          echo "Waiting for server to start..."
          for i in {1..30}; do
            if curl -s http://localhost:3000 > /dev/null; then
              echo "Server is ready!"
              break
            fi
            sleep 1
          done

          # Run Lighthouse CI with build config
          npx lhci autorun --config=.lighthouserc.build.json || {
            echo "âš ï¸ Lighthouse checks failed - performance regression detected"
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          }

          # Clean up
          kill $SERVER_PID 2>/dev/null || true
        env:
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}

  ci-unit-tests:
    name: Unit Tests
    # Optimized: only wait for typecheck, lint can run in parallel (doesn't affect tests)
    needs: [ci-typecheck]
    # Unit tests run on push to main or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      # Check if test-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'test'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping unit tests as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Load quarantined unit tests
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: quarantine
        run: |
          FILE="apps/web/tests/quarantine.json"
          UNIT_FILES=""
          UNIT_EXCLUDES=""

          if [ -f "$FILE" ]; then
            UNIT_FILES=$(jq -r '.unit // [] | join(" ")' "$FILE")
            UNIT_EXCLUDES=$(jq -r '.unit // [] | map("--exclude=" + .) | join(" ")' "$FILE")
          fi

          echo "unit_files=$UNIT_FILES" >> $GITHUB_OUTPUT
          echo "unit_excludes=$UNIT_EXCLUDES" >> $GITHUB_OUTPUT

          if [ -n "$UNIT_FILES" ]; then
            echo "has_unit=true" >> $GITHUB_OUTPUT
          else
            echo "has_unit=false" >> $GITHUB_OUTPUT
          fi

      - name: Run unit tests
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run test -- ${{ steps.quarantine.outputs.unit_excludes }}
        env:
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}

      - name: Run quarantined unit tests (retries)
        if: steps.check_changes.outputs.run_full_ci == 'true' && steps.quarantine.outputs.has_unit == 'true'
        continue-on-error: true
        run: cd apps/web && pnpm vitest run --config=vitest.config.mts --retry=2 ${{ steps.quarantine.outputs.unit_files }}
        env:
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}

  ci-merge-smoke:
    name: Merge Group Smoke
    if: ${{ github.event_name == 'merge_group' }}
    needs: [ci-fast]
    runs-on: ubuntu-latest
    timeout-minutes: 7
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2
      - uses: ./.github/actions/setup-node-pnpm
      - name: Build (smoke)
        run: pnpm --filter=@jovie/web run build
        env:
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          NEXT_IGNORE_ESLINT: '1'
          NEXT_IGNORE_TYPECHECK: '1'
          NEXT_PRIVATE_SKIP_SIZE_CHECK: 'true'

  ci-e2e-tests:
    name: E2E Tests
    needs: [ci-build, neon-db]
    # E2E runs on push to main or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      # Check if E2E-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'e2e'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping E2E tests as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Resolve Neon DB URL (job-local)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: resolve_neon
        uses: neondatabase/create-branch-action@72ed4f69a12b6be9c16aebfad893f6a21e9aba8b # v6.4.0
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ needs.neon-db.outputs.branch_name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL for E2E
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.resolve_neon.outputs.db_url }}"
          SRC=""
          if [ -n "$CANDIDATE" ]; then
            echo "Using Neon DB URL from neon-db job outputs"
            echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV
            SRC="neon-job-output"
          else
            echo "No Neon ephemeral DB URL available from neon-db job."
            SRC="unresolved"
          fi
          echo "RESOLVED_DB_SOURCE=$SRC" >> $GITHUB_ENV

      - name: Fail if Neon DB URL is missing (E2E)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          if [[ -z "$DATABASE_URL" ]]; then
            echo "No Neon ephemeral DATABASE_URL available. Refusing to run E2E against staging/production DBs."
            exit 1
          fi

      - name: Run migrations for E2E DB
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:migrate:ci
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NODE_ENV: test
          GIT_BRANCH: ${{ github.ref_name }}
          ALLOW_PROD_MIGRATIONS: 'true'

      - name: Cache Playwright Browsers
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('pnpm-lock.yaml', 'package.json', 'playwright.config*.ts') }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: Install Playwright
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: |
          # Always Chrome-only for speed; Firefox runs weekly via e2e-full-matrix workflow
          pnpm --filter=@jovie/web exec playwright install chromium --with-deps

      - name: Load quarantined E2E specs
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        id: quarantine
        run: |
          FILE="apps/web/tests/quarantine.json"
          QUARANTINED=()

          if [ -f "$FILE" ]; then
            mapfile -t QUARANTINED < <(jq -r '.e2e // [] | .[]' "$FILE")
          fi

          mapfile -t ALL_SPECS < <(git ls-files "apps/web/tests/e2e/**/*.spec.ts" "apps/web/tests/smoke/**/*.spec.ts")

          ALLOWED_SPECS=()
          for spec in "${ALL_SPECS[@]}"; do
            skip=false
            for quarantined in "${QUARANTINED[@]}"; do
              if [[ "$spec" == "$quarantined" ]]; then
                skip=true
                break
              fi
            done
            if [[ "$skip" == "false" ]]; then
              ALLOWED_SPECS+=("$spec")
            fi
          done

          echo "allowed_specs=${ALLOWED_SPECS[*]}" >> $GITHUB_OUTPUT
          echo "quarantined_specs=${QUARANTINED[*]}" >> $GITHUB_OUTPUT

          if [ ${#QUARANTINED[@]} -gt 0 ]; then
            echo "has_quarantine=true" >> $GITHUB_OUTPUT
          else
            echo "has_quarantine=false" >> $GITHUB_OUTPUT
          fi

      - name: E2E Smoke (PR to Preview)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && github.event_name == 'pull_request' && github.ref != 'refs/heads/production' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        env:
          SMOKE_ONLY: '1'
        run: |
          if [ -z "${{ steps.quarantine.outputs.allowed_specs }}" ]; then
            echo "No non-quarantined E2E specs to run."
            exit 0
          fi
          # Chrome-only for PRs - faster feedback, Firefox runs on main only
          cd apps/web && pnpm e2e:smoke --trace=retain-on-failure --project=chromium ${{ steps.quarantine.outputs.allowed_specs }}

      - name: E2E Auth Smoke (PR Gate)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && github.event_name == 'pull_request' && github.ref != 'refs/heads/production' && hashFiles('apps/web/tests/e2e/auth-smoke.spec.ts') != '' }}
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NODE_ENV: test
          SMOKE_ONLY: '1'
          # Auth smoke requires real Clerk keys in CI
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}
          # Auth smoke signs in a configured E2E user
          E2E_CLERK_USER_USERNAME: ${{ secrets.E2E_CLERK_USER_USERNAME }}
          E2E_CLERK_USER_PASSWORD: ${{ secrets.E2E_CLERK_USER_PASSWORD }}
          # Optional: enable deterministic spotify-only UI check
          NEXT_PUBLIC_STATSIG_CLIENT_KEY: ${{ secrets.NEXT_PUBLIC_STATSIG_CLIENT_KEY }}
        run: |
          cd apps/web && pnpm --filter=@jovie/web run e2e:auth-smoke --project=chromium

      - name: E2E Full (Main Branch)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && github.ref == 'refs/heads/main' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: |
          if [ -z "${{ steps.quarantine.outputs.allowed_specs }}" ]; then
            echo "No non-quarantined E2E specs to run."
            exit 0
          fi
          cd apps/web && pnpm playwright test --reporter=line ${{ steps.quarantine.outputs.allowed_specs }}

      - name: E2E Quarantine (retries)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && steps.quarantine.outputs.has_quarantine == 'true' }}
        continue-on-error: true
        run: cd apps/web && pnpm playwright test --reporter=line --retries=2 ${{ steps.quarantine.outputs.quarantined_specs }}

      - name: Upload Playwright Report on Failure
        if: ${{ failure() && steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: ${{ github.job }}-playwright-report-${{ github.run_id }}-${{ github.run_attempt }}
          path: apps/web/playwright-report/
          retention-days: 7

      - name: Upload Playwright Test Results on Failure
        if: ${{ failure() && steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: ${{ github.job }}-test-results-${{ github.run_id }}-${{ github.run_attempt }}
          path: apps/web/test-results/
          retention-days: 7

  ci-test-performance:
    name: Test Performance Budgets
    needs: [ci-typecheck]
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 2

      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'test'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping test performance budgets; no relevant paths changed."
          exit 0

      - uses: ./.github/actions/setup-node-pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'

      - name: Generate test performance profile
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm test:profile

      - name: Enforce test performance budgets
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          SUITE="critical"
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            SUITE="full"
          fi

          TEST_PERFORMANCE_SUITE="$SUITE" TEST_PERFORMANCE_USE_BASELINE="true" pnpm test:guard -- --suite="$SUITE" --use-baseline
  ci-pr-vercel-preview:
    name: Preview Deploy (PR)
    # Only needs build - no DB dependencies for fast UI-only PRs
    needs: [ci-build]
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      deployment_url: ${{ steps.pr_deploy.outputs.deployment_url }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6.1.0
        with:
          node-version: 20
          package-manager-cache: false
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: Pull env (preview)
        run: vercel pull --yes --environment=preview --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build (PR preview)
        run: vercel build --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          COREPACK_ENABLE_DOWNLOAD_PROMPT: 0
          COREPACK_ENABLE_STRICT: 0
      - name: Deploy (PR preview, fast deployment for UI-only changes)
        id: pr_deploy
        run: |
          # For fast preview PRs: use main secrets (no Neon dependency)
          # Fallback hierarchy for maximum compatibility
          POOLED_URL=""
          if [ -n "$DATABASE_URL_MAIN" ]; then
            POOLED_URL="$DATABASE_URL_MAIN"
            echo "Using main database URL"
          elif [ -n "$DATABASE_URL" ]; then
            POOLED_URL="$DATABASE_URL"
            echo "Using fallback database URL"
          else
            # Provide cheap stub for UI-only deployments that might not need DB
            POOLED_URL="postgresql://stub:stub@localhost:5432/main_stub"
            echo "Using stub database URL for UI-only deployment"
          fi

          # Deploy preview with DATABASE_URL injected only for this deployment
          deployment_url=$(vercel deploy --prebuilt \
            --env DATABASE_URL="$POOLED_URL" \
            --env GIT_BRANCH="${GIT_BRANCH}" \
            --token $VERCEL_TOKEN)

          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          # Use main secrets - no Neon dependency for fast deployments
          DATABASE_URL_MAIN: ${{ secrets.DATABASE_URL_MAIN }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GIT_BRANCH: ${{ github.head_ref || github.ref_name }}

  ci-lighthouse-pr:
    name: Lighthouse (PR Gate)
    needs: [ci-pr-vercel-preview]
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - uses: ./.github/actions/setup-node-pnpm

      - name: Run Lighthouse CI against PR preview (Homepage + Profile)
        run: |
          set -euo pipefail

          PREVIEW_URL="${{ needs.ci-pr-vercel-preview.outputs.deployment_url }}"
          if [ -z "$PREVIEW_URL" ]; then
            echo "No preview deployment URL available. Refusing to run Lighthouse PR gate."
            exit 1
          fi

          echo "Running Lighthouse against: $PREVIEW_URL"

          # Lighthouse expects a local server URL in config; override via CLI so we can hit Vercel Preview
          cd apps/web
          npx lhci autorun \
            --config=.lighthouserc.pr.json \
            --collect.url="$PREVIEW_URL/" \
            --collect.url="$PREVIEW_URL/tim"

  ci-summary:
    name: CI Summary
    if: ${{ always() && github.event_name == 'pull_request' }}
    permissions:
      actions: read
      pull-requests: write
      contents: read
    needs:
      - ci-env-example-guard
      - ci-guardrails
      - ci-typecheck
      - ci-biome
      - neon-db
      - drizzle-migration-guard
      - ci-drizzle-check
      - ci-fast
      - ci-pr-neon-migrate
      - ci-build
      - ci-unit-tests
      - ci-test-performance
      - ci-e2e-tests
      - ci-pr-vercel-preview
      - ci-lighthouse-pr
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Post CI summary to PR
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          BUILD_RUN_FULL_CI: ${{ needs.ci-build.outputs.run_full_ci }}
          DRIZZLE_RUN_FULL_CI: ${{ needs.ci-drizzle-check.outputs.run_full_ci }}
          E2E_RUN_FULL_CI: ${{ needs.ci-e2e-tests.outputs.run_full_ci }}
          MIGRATION_GUARD_RUN_FULL_CI: ${{ needs.drizzle-migration-guard.outputs.run_full_ci }}
          PR_MIGRATE_RUN_FULL_CI: ${{ needs.ci-pr-neon-migrate.outputs.run_full_ci }}
          UNIT_RUN_FULL_CI: ${{ needs.ci-unit-tests.outputs.run_full_ci }}
          PR_PREVIEW_URL: ${{ needs.ci-pr-vercel-preview.outputs.deployment_url }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const runId = context.runId;

            const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id: runId,
              per_page: 100
            });

            const jobByName = new Map(
              jobsResponse.data.jobs.map(job => [job.name, job])
            );

            const formatDuration = (job) => {
              if (!job?.started_at || !job?.completed_at) return 'â€”';
              const start = new Date(job.started_at);
              const end = new Date(job.completed_at);
              const ms = Math.max(0, end - start);
              const minutes = Math.floor(ms / 60000);
              const seconds = Math.floor((ms % 60000) / 1000);
              return minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            };

            const resolveOutcome = (jobName, fallbackResult) => {
              const job = jobByName.get(jobName);
              if (!job) return { status: fallbackResult ?? 'not_run', duration: 'â€”' };
              return {
                status: job.conclusion || job.status || fallbackResult || 'unknown',
                duration: formatDuration(job)
              };
            };

            const summarizeStatus = (status) => {
              switch (status) {
                case 'success':
                  return 'âœ… Passed';
                case 'failure':
                  return 'âŒ Failed';
                case 'cancelled':
                  return 'âš ï¸ Cancelled';
                case 'skipped':
                  return 'âš ï¸ Skipped';
                case 'timed_out':
                  return 'âŒ Timed out';
                case 'not_run':
                  return 'âšªï¸ Not run';
                default:
                  return `âšªï¸ ${status}`;
              }
            };

            const deriveSkipReason = (jobKey, runFullCiFlag) => {
              if (runFullCiFlag === 'false') {
                return 'Skipped (path guard: no relevant changes)';
              }
              if (runFullCiFlag === '') {
                return 'Skipped (job not applicable)';
              }
              return jobKey === 'neon-db'
                ? 'Skipped (not required for this PR)'
                : 'Skipped (conditional job)';
            };

            const summaryRows = [
              { label: 'Env Example Guard', jobName: 'Env Example Guard' },
              { label: 'Guardrails', jobName: 'Guardrails (proxy)' },
              { label: 'Biome', jobName: 'Biome (lint + format)' },
              {
                label: 'Migration Guard',
                jobName: 'Migration Guard',
                runFullCi: process.env.MIGRATION_GUARD_RUN_FULL_CI
              },
              { label: 'Neon DB', jobName: 'Neon DB' },
              {
                label: 'Drizzle Check',
                jobName: 'Drizzle Check',
                runFullCi: process.env.DRIZZLE_RUN_FULL_CI
              },
              {
                label: 'Build',
                jobName: 'Build',
                runFullCi: process.env.BUILD_RUN_FULL_CI
              },
              {
                label: 'Unit Tests',
                jobName: 'Unit Tests',
                runFullCi: process.env.UNIT_RUN_FULL_CI
              },
              {
                label: 'Test Performance Budgets',
                jobName: 'Test Performance Budgets'
              },
              {
                label: 'E2E Tests',
                jobName: 'E2E Tests',
                runFullCi: process.env.E2E_RUN_FULL_CI
              },
              {
                label: 'DB Migrate (PR main)',
                jobName: 'DB Migrate (PR main)',
                runFullCi: process.env.PR_MIGRATE_RUN_FULL_CI
              },
              { label: 'Preview Deploy', jobName: 'Preview Deploy (PR)' }
            ];

            const rows = summaryRows.map((row) => {
              const outcome = resolveOutcome(row.jobName);
              const statusLabel = summarizeStatus(outcome.status);
              const timing = outcome.duration;
              let context = 'Executed';
              if (outcome.status === 'skipped' || outcome.status === 'not_run') {
                context = deriveSkipReason(row.label, row.runFullCi ?? '');
              }
              return `| ${row.label} | ${statusLabel} | ${context} | ${timing} |`;
            });

            // Add preview URL section if available
            let previewUrlSection = '';
            if (process.env.PR_PREVIEW_URL) {
              previewUrlSection = `\nðŸ”— **Preview Deployment**: ${process.env.PR_PREVIEW_URL}\n`;
            }

            const summaryBody = [
              '## CI Summary',
              '',
              'A crisp snapshot of this PR run â€” executed vs. skipped, with timing for every key lane.',
              previewUrlSection,
              '',
              '| Job | Status | Context | Time |',
              '| --- | ------ | ------- | ---- |',
              ...rows,
              '',
              `**Run:** [${runId}](${context.serverUrl}/${owner}/${repo}/actions/runs/${runId})`,
              ''
            ].join('\n');

            const existingComments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber
            });

            const botComment = existingComments.data.find(comment =>
              comment.user?.type === 'Bot' && comment.body?.startsWith('## CI Summary')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: summaryBody
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: summaryBody
              });
            }
  # CRITICAL: Required smoke tests run BEFORE production deploy
  # These tests verify the most critical user flows: public profiles + auth
  ci-smoke-required:
    name: Smoke Tests (Required)
    needs: [ci-fast, ci-build, neon-db]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1

      - uses: ./.github/actions/setup-node-pnpm

      - name: Resolve Neon DB URL (job-local)
        id: resolve_neon
        uses: neondatabase/create-branch-action@72ed4f69a12b6be9c16aebfad893f6a21e9aba8b # v6.4.0
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ needs.neon-db.outputs.branch_name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Cache Playwright Browsers
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-chromium-${{ hashFiles('pnpm-lock.yaml', 'package.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-chromium-

      - name: Install Playwright (Chromium only)
        run: pnpm --filter=@jovie/web exec playwright install chromium --with-deps

      - name: Run Required Smoke Tests
        run: |
          CI=true pnpm --filter=@jovie/web run test:e2e tests/e2e/smoke-required.spec.ts --project=chromium --reporter=line
        env:
          DATABASE_URL: ${{ steps.resolve_neon.outputs.db_url }}

      - name: Upload Playwright Artifacts on Failure
        if: failure()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: smoke-required-report-${{ github.run_id }}
          path: |
            apps/web/playwright-report/
            apps/web/test-results/
          retention-days: 3

  # CRITICAL: Homepage smoke test runs BEFORE production deploy
  # This prevents broken homepages from reaching production
  ci-homepage-smoke:
    name: Homepage Smoke (Pre-Deploy)
    needs: [ci-fast, ci-build]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 1

      - uses: ./.github/actions/setup-node-pnpm

      - name: Cache Playwright Browsers
        uses: actions/cache@9255dc7a253b0ccc959486e2bca901246202afeb # v5.0.1
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-chromium-${{ hashFiles('pnpm-lock.yaml', 'package.json') }}
          restore-keys: |
            ${{ runner.os }}-playwright-chromium-

      - name: Install Playwright (Chromium only)
        run: pnpm --filter=@jovie/web exec playwright install chromium --with-deps

      - name: Run Homepage Smoke Test against production
        run: |
          CI=true BASE_URL=https://meetjovie.com pnpm --filter=@jovie/web run test:e2e tests/e2e/homepage-smoke.spec.ts --project=chromium --reporter=line
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Upload Playwright Artifacts on Failure
        if: failure()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: homepage-smoke-report-${{ github.run_id }}
          path: |
            apps/web/playwright-report/
            apps/web/test-results/
          retention-days: 3

  deploy:
    needs: [ci-fast, ci-build, ci-unit-tests, ci-e2e-tests, ci-smoke-required, ci-homepage-smoke] # Required smoke + homepage smoke must pass before deploy
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
      migration_status: ${{ steps.migrate.outcome }}
      preflight_status: ${{ steps.preflight.outcome }}
    env:
      # Trunk-based: main deploys directly to production
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
    environment:
      name: Production â€“ jovie
      url: https://jov.ie
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: DB safety check (production - preflight)
        id: preflight
        run: pnpm --filter=@jovie/web exec tsx scripts/drizzle-migrate-preflight.ts
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GIT_BRANCH: main
          ALLOW_PROD_MIGRATIONS: 'true'
      - name: DB migrate (production - Drizzle)
        id: migrate
        run: pnpm --filter=@jovie/web run drizzle:migrate:ci
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GIT_BRANCH: main
          ALLOW_PROD_MIGRATIONS: 'true'
        continue-on-error: false
      - name: Upgrade corepack
        run: npm install -g corepack@latest && corepack enable
      - name: Pull env (production)
        run: vercel pull --yes --environment=production --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build (production)
        run: vercel build --prod --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          COREPACK_ENABLE_DOWNLOAD_PROMPT: 0
          COREPACK_ENABLE_STRICT: 0
      - name: Deploy (production, prebuilt)
        id: deploy
        run: |
          deployment_url=$(vercel deploy --prebuilt --prod --token ${{ secrets.VERCEL_TOKEN }})
          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  canary-health-gate:
    name: Canary Health Gate (production)
    needs: [deploy]
    if: ${{ needs.deploy.result == 'success' }}
    uses: ./.github/workflows/canary-health-gate.yml
    with:
      deployment_url: ${{ needs.deploy.outputs.deployment_url }}
      fallback_health_url: https://jov.ie/api/health
    secrets:
      VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  deploy-notify:
    name: Notify production deploy
    needs: [deploy, canary-health-gate]
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve failure provenance
        id: failure-provenance
        if: ${{ always() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          api_url="${{ github.api_url }}/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs?per_page=100"
          response=$(curl -sS -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "$api_url")
          job_url=$(RESPONSE="$response" JOB_NAME="${{ github.job }}" python - <<'PY'
          import json
          import os

          data = json.loads(os.environ["RESPONSE"])
          job_name = os.environ["JOB_NAME"]
          job = next((item for item in data.get("jobs", []) if item.get("name") == job_name), None)
          print(job.get("html_url", "") if job else "")
          PY
          )

          if [ -z "$job_url" ]; then
            job_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}?check_suite_focus=true"
          fi

          echo "job_name=${{ github.job }}" >> "$GITHUB_OUTPUT"
          echo "job_url=$job_url" >> "$GITHUB_OUTPUT"

      - name: Slack notify (production deploy)
        if: ${{ needs.deploy.result == 'success' && needs.canary-health-gate.result == 'success' && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@77eaa4f1c608a7d68b38af4e3f739dcd8cba273e # v3.19.0
        with:
          status: custom
          channel: '#alerts-production'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "âœ… Production deployed: jov.ie",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Workflow", "value": "CI", "short": true },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Classify failure type
        id: classify-failure
        if: ${{ always() && (needs.deploy.result != 'success' || needs.canary-health-gate.result != 'success') }}
        run: |
          # Determine failure type for accurate Slack notification
          MIGRATION_STATUS="${{ needs.deploy.outputs.migration_status }}"
          PREFLIGHT_STATUS="${{ needs.deploy.outputs.preflight_status }}"
          DEPLOY_RESULT="${{ needs.deploy.result }}"
          CANARY_RESULT="${{ needs.canary-health-gate.result }}"

          if [ "$PREFLIGHT_STATUS" = "failure" ]; then
            echo "failure_type=migration_preflight" >> "$GITHUB_OUTPUT"
            echo "failure_emoji=ðŸš¨" >> "$GITHUB_OUTPUT"
            echo "failure_title=DATABASE MIGRATION PREFLIGHT FAILED" >> "$GITHUB_OUTPUT"
            echo "failure_detail=Migration preflight check failed - deployment was BLOCKED before any changes were made" >> "$GITHUB_OUTPUT"
          elif [ "$MIGRATION_STATUS" = "failure" ]; then
            echo "failure_type=migration" >> "$GITHUB_OUTPUT"
            echo "failure_emoji=ðŸš¨" >> "$GITHUB_OUTPUT"
            echo "failure_title=DATABASE MIGRATION FAILED" >> "$GITHUB_OUTPUT"
            echo "failure_detail=Migration failed on production database - deployment was BLOCKED (no code deployed)" >> "$GITHUB_OUTPUT"
          elif [ "$DEPLOY_RESULT" != "success" ]; then
            echo "failure_type=deploy" >> "$GITHUB_OUTPUT"
            echo "failure_emoji=ðŸ”¥" >> "$GITHUB_OUTPUT"
            echo "failure_title=Production deploy failed" >> "$GITHUB_OUTPUT"
            echo "failure_detail=Vercel deployment failed" >> "$GITHUB_OUTPUT"
          elif [ "$CANARY_RESULT" != "success" ]; then
            echo "failure_type=canary" >> "$GITHUB_OUTPUT"
            echo "failure_emoji=âš ï¸" >> "$GITHUB_OUTPUT"
            echo "failure_title=CANARY HEALTH CHECK FAILED" >> "$GITHUB_OUTPUT"
            echo "failure_detail=Deployment is LIVE but health check failed - investigate immediately" >> "$GITHUB_OUTPUT"
          else
            echo "failure_type=unknown" >> "$GITHUB_OUTPUT"
            echo "failure_emoji=â“" >> "$GITHUB_OUTPUT"
            echo "failure_title=Production deploy failed" >> "$GITHUB_OUTPUT"
            echo "failure_detail=Unknown failure - check workflow logs" >> "$GITHUB_OUTPUT"
          fi

      - name: Slack notify (migration failure - CRITICAL)
        if: ${{ always() && steps.classify-failure.outputs.failure_type == 'migration' && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@77eaa4f1c608a7d68b38af4e3f739dcd8cba273e # v3.19.0
        with:
          status: custom
          channel: '#alerts-critical'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "ðŸš¨ DATABASE MIGRATION FAILED - Production deploy BLOCKED: jov.ie",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Status", "value": "ðŸ›‘ DEPLOYMENT BLOCKED - No code was deployed", "short": false },
                    { "title": "Failure", "value": "Database migration failed", "short": true },
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Action Required", "value": "Fix migration and re-run pipeline", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View logs>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack notify (migration preflight failure - CRITICAL)
        if: ${{ always() && steps.classify-failure.outputs.failure_type == 'migration_preflight' && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@77eaa4f1c608a7d68b38af4e3f739dcd8cba273e # v3.19.0
        with:
          status: custom
          channel: '#alerts-critical'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "ðŸš¨ MIGRATION PREFLIGHT FAILED - Production deploy BLOCKED: jov.ie",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Status", "value": "ðŸ›‘ DEPLOYMENT BLOCKED - Preflight safety check failed", "short": false },
                    { "title": "Failure", "value": "Migration preflight validation failed", "short": true },
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Action Required", "value": "Check migration journal integrity and database state", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View logs>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack notify (canary failure - URGENT)
        if: ${{ always() && steps.classify-failure.outputs.failure_type == 'canary' && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@77eaa4f1c608a7d68b38af4e3f739dcd8cba273e # v3.19.0
        with:
          status: custom
          channel: '#alerts-critical'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "âš ï¸ CANARY HEALTH CHECK FAILED - Deployment may be broken: jov.ie",
              "attachments": [
                {
                  "color": "warning",
                  "fields": [
                    { "title": "Status", "value": "âš ï¸ DEPLOYMENT IS LIVE but health check failed", "short": false },
                    { "title": "Failure", "value": "Canary health gate failed", "short": true },
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Action Required", "value": "Check https://jov.ie immediately - may need rollback", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View logs>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack notify (general deploy failure)
        if: ${{ always() && (steps.classify-failure.outputs.failure_type == 'deploy' || steps.classify-failure.outputs.failure_type == 'unknown') && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@77eaa4f1c608a7d68b38af4e3f739dcd8cba273e # v3.19.0
        with:
          status: custom
          channel: '#alerts-critical'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "ðŸ”¥ Production deploy failed: jov.ie",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Failing job", "value": "${{ steps.failure-provenance.outputs.job_name }}", "short": true },
                    { "title": "Failing job URL", "value": "<${{ steps.failure-provenance.outputs.job_url }}|View job>", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Lighthouse CI - runs after production deploy
  lighthouse-ci:
    name: Lighthouse CI (Production)
    needs: [deploy]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      - uses: ./.github/actions/setup-node-pnpm
      - name: Run Lighthouse CI against production
        run: npx lhci autorun --config=.lighthouserc.json
