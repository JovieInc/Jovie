name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main, 'codegen-bot/**']
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
  workflow_dispatch:

permissions: read-all

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:

  ci-env-example-guard:
    name: Env Example Guard
    # Always run; fast, prevents accidental secret commits.
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Validate .env.example contains placeholders only
        run: |
          set -euo pipefail

          if [ ! -f .env.example ]; then
            echo "No .env.example found; skipping."
            exit 0
          fi

          # Fail on common secret/token prefixes.
          if grep -nE '(sk_live_|sk_test_|rk_live_|rk_test_|whsec_|ghp_|github_pat_|xoxb-|BEGIN PRIVATE KEY|-----BEGIN)' .env.example; then
            echo "âŒ .env.example appears to contain a real secret/token. Replace with placeholders."
            exit 1
          fi

          # Fail on real-looking Stripe price IDs (these should be placeholders).
          if grep -nE '^STRIPE_PRICE_.*=price_[A-Za-z0-9]+' .env.example; then
            echo "âŒ .env.example contains Stripe price IDs. Replace with placeholders."
            exit 1
          fi

          echo "âœ… .env.example looks safe (no obvious secrets)."

  ci-guardrails:
    name: Guardrails (proxy + format)
    # Draft PRs skip; ready PRs + pushes enforce core repo guardrails
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping guardrails."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping guardrails."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Next.js proxy guard
        run: pnpm --filter=@jovie/web run next:proxy-guard
      - name: Format check (Biome)
        run: pnpm run format:check

  ci-fast-checks:
    name: Fast checks (typecheck + lint)
    # Draft PRs skip; ready PRs + pushes run fast checks in parallel
    needs: [ci-cache-warm]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        check: [typecheck, lint]
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping fast checks."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping fast checks."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Cache Turbo
        uses: actions/cache@v5
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-
      - name: Cache TypeScript artifacts
        if: ${{ matrix.check == 'typecheck' }}
        uses: actions/cache@v5
        with:
          path: |
            .cache/tsbuildinfo
            apps/web/.cache/tsbuildinfo
          key: ${{ runner.os }}-tsc-${{ github.ref }}-${{ hashFiles('**/tsconfig.json', '**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-tsc-${{ github.ref }}-
            ${{ runner.os }}-tsc-
      - name: Run fast/lint check
        run: |
          if [[ "${{ matrix.check }}" == "typecheck" ]]; then
            pnpm turbo typecheck --filter=@jovie/web
          else
            pnpm turbo lint --filter=@jovie/web
          fi
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_TEAM: ${{ vars.TURBO_TEAM }}

  ci-cache-warm:
    name: Cache Warm (pnpm + Next build cache)
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v6
        with: { fetch-depth: 1 }
      - name: Short-circuit for docs-only / empty-diff PR updates
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          set -euo pipefail

          git fetch origin "${{ github.base_ref }}" --depth=1
          CHANGED_FILES=$(git diff --name-only "origin/${{ github.base_ref }}" HEAD)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No diff vs base branch (merge-only / empty PR update). Skipping cache warm."
            exit 0
          fi

          # Match the old trigger-level ignore behavior (but keep CI runnable for empty diffs)
          if echo "$CHANGED_FILES" | grep -v -E '^(docs/|\.vscode/|.*\.md$)' | wc -l | grep -q '^0$'; then
            echo "Docs-only change. Skipping cache warm."
            exit 0
          fi
      - uses: ./.github/actions/setup-node-pnpm
      - name: Cache Turbo
        uses: actions/cache@v5
        with:
          path: .turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-
      - name: Cache Next build cache
        uses: actions/cache@v5
        with:
          path: |
            apps/web/.next/cache
            .turbo
          key: ${{ runner.os }}-next-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-next-${{ hashFiles('**/pnpm-lock.yaml') }}-
            ${{ runner.os }}-next-
          save-always: true
      - name: Warm Next build cache
        if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false }}
        run: pnpm turbo build --filter=@jovie/web
        env:
          TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
          TURBO_TEAM: ${{ vars.TURBO_TEAM }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN || 'https://placeholder.supabase.co' }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN || 'placeholder' }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN || 'placeholder' }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY || 'placeholder' }}
          NEXT_IGNORE_ESLINT: '1'
          NEXT_IGNORE_TYPECHECK: '1'
          NEXT_PRIVATE_SKIP_SIZE_CHECK: 'true'

  neon-db:
    name: Neon DB
    # Only run for push and PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      branch_name: ${{ steps.sanitize-branch.outputs.name }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - name: Cleanup old Neon branches (prevent limit errors)
        uses: ./.github/actions/neon-branch-cleanup
        with:
          neon_api_key: ${{ secrets.NEON_API_KEY }}
          neon_project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_limit: '10'
          protected_branches: 'main,br-main'
          cleanup_threshold: '7'

      - name: Determine sanitized branch name
        id: sanitize-branch
        run: |
          RAW="${{ github.head_ref || github.ref_name }}"

          # Avoid collisions with protected long-lived branches in Neon.
          # For push to main we reuse the long-lived Neon branch.
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref_name }}" == "main" ]]; then
            RAW="${{ github.ref_name }}"
          fi

          # sanitize: lowercase, replace slashes with dashes, remove invalid chars, collapse repeats
          SANITIZED=$(echo "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's|/|-|g; s|[^a-z0-9._-]|-|g; s/-{2,}/-/g; s/^-+//; s/-+$//')
          BASE=$(echo "$SANITIZED" | cut -c1-40)
          SUFFIX="${{ github.run_id }}-${{ github.run_attempt }}"
          FINAL="${BASE}-${SUFFIX}"
          echo "Using sanitized branch name: $FINAL"
          echo "name=$FINAL" >> $GITHUB_OUTPUT
      - name: Create or reuse Neon branch
        id: create-branch
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ steps.sanitize-branch.outputs.name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}
      - name: Finalize Neon DB URLs
        id: finalize-urls
        run: |
          DB_URL="${{ steps.create-branch.outputs.db_url }}"
          DB_URL_POOLED="${{ steps.create-branch.outputs.db_url_pooled }}"

          if [ -z "$DB_URL" ]; then
            echo "Neon branch creation did not return db_url."
            echo "This indicates NEON_PROJECT_ID/NEON_API_KEY or the create-branch action is failing."
            exit 1
          fi

          # Intentionally do NOT expose DB_URL via job outputs.
          # GitHub will drop outputs that look like secrets, which breaks downstream jobs.
          echo "Neon DB URL resolved for this job."

  drizzle-migration-guard:
    name: Migration Guard
    # Skip if 'skip-migration-guard' label is present (for schema consolidation)
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && !contains(github.event.pull_request.labels.*.name, 'skip-migration-guard')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 3
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip notification (updated condition)
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping migration guard as no DB/schema paths were changed."
          exit 0
      - name: Run Migration Guard
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          # Make script executable
          chmod +x apps/web/scripts/check-migrations.sh
          chmod +x apps/web/scripts/validate-migrations.sh

          # Run migration guard and validation from apps/web directory
          cd apps/web
          ./scripts/check-migrations.sh
          ./scripts/validate-migrations.sh
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}

  ci-drizzle-check:
    name: Drizzle Check
    needs: [neon-db]  # Optimized: only needs DB, can run parallel with typecheck/lint
    # Only run on push or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Check if Drizzle-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping Drizzle check as no DB/schema paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      - name: Resolve Neon DB URL (job-local)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: resolve_neon
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ needs.neon-db.outputs.branch_name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL (Neon ephemeral)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.resolve_neon.outputs.db_url }}"
          if [ -n "$CANDIDATE" ]; then
            echo "Using Neon DB URL from neon-db job outputs"
            echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV
          else
            echo "No Neon ephemeral DB URL available from neon-db job."
          fi

      - name: Fail if Neon DB URL is missing
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          if [[ -z "$DATABASE_URL" ]]; then
            echo "No Neon ephemeral DATABASE_URL available. Refusing to run Drizzle check against production DB."
            exit 1
          fi

      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Run Drizzle Check
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:check

  ci-fast:
    name: ci-fast
    # Gate for PRs and pushes: aggregate fast checks
    needs: [ci-fast-checks, ci-guardrails]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: All fast checks passed
        run: |
          echo "ci-fast passed: Typecheck and Lint succeeded"

  ci-pr-neon-migrate:
    name: DB Migrate (PR main)
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    timeout-minutes: 12
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - name: Cleanup old Neon branches (prevent limit errors)
        uses: ./.github/actions/neon-branch-cleanup
        with:
          neon_api_key: ${{ secrets.NEON_API_KEY }}
          neon_project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_limit: '10'
          protected_branches: 'main,br-main'
          cleanup_threshold: '7'

      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'drizzle'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event.pull_request.head.repo.fork }}

      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping DB migrate check: no DB/schema/migration paths were changed."
          exit 0

      - name: Determine sanitized Neon branch name
        id: sanitize-branch
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          RAW="${{ github.head_ref }}"
          SANITIZED=$(echo "$RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's|/|-|g; s|[^a-z0-9._-]|-|g; s/-{2,}/-/g; s/^-+//; s/-+$//')
          BASE=$(echo "$SANITIZED" | cut -c1-40)
          SUFFIX="${{ github.run_id }}-${{ github.run_attempt }}"
          FINAL="${BASE}-${SUFFIX}"
          echo "Using sanitized branch name: $FINAL"
          echo "name=$FINAL" >> $GITHUB_OUTPUT

      - name: Create or reuse Neon branch
        id: create-branch
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ steps.sanitize-branch.outputs.name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL (Neon ephemeral)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.create-branch.outputs.db_url }}"
          if [ -z "$CANDIDATE" ]; then
            echo "No Neon ephemeral DATABASE_URL available."
            exit 1
          fi
          echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV

      - uses: ./.github/actions/setup-node-pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'

      - name: Run migrations (ephemeral Neon)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:migrate
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NODE_ENV: test
          GIT_BRANCH: pr-${{ github.event.pull_request.number }}
          ALLOW_PROD_MIGRATIONS: 'true'

  # Public Profile Smoke Test - runs against main.jov.ie (staging) to verify public profiles work
  # This test runs on pushes to main after deploy completes
  ci-public-profile-smoke:
    name: Public Profile Smoke
    needs: [deploy]
    # Only run after successful deploy to main staging
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - uses: ./.github/actions/setup-node-pnpm

      - name: Cache Playwright Browsers
        uses: actions/cache@v5
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-chromium-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-playwright-chromium-

      - name: Install Playwright (Chromium only)
        run: pnpm --filter=@jovie/web exec playwright install chromium --with-deps

      - name: Run Public Profile Smoke Test against staging
        run: |
          CI=true BASE_URL=https://main.jov.ie pnpm --filter=@jovie/web run test:e2e tests/e2e/public-profile-smoke.spec.ts --project=chromium --reporter=line
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Run Performance Budget Guard against staging
        run: |
          CI=true BASE_URL=https://main.jov.ie pnpm --filter=@jovie/web run test:budgets
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

      - name: Upload Playwright Artifacts on Failure
        if: failure()
        uses: actions/upload-artifact@v6
        with:
          name: public-profile-smoke-report-${{ github.run_id }}
          path: |
            playwright-report/
            test-results/
          retention-days: 3

  ci-build:
    name: Build
    needs: [ci-fast-checks]
    # Only run on push or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Path guard: Check if changes affect critical files
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'build'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping full CI as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Cache Next build cache
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: actions/cache@v5
        with:
          path: .next/cache
          key: ${{ runner.os }}-next-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-next-

      - name: Build
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
          NEXT_IGNORE_ESLINT: '1'
          NEXT_IGNORE_TYPECHECK: '1'
          NEXT_PRIVATE_SKIP_SIZE_CHECK: 'true'

  ci-unit-tests:
    name: Unit Tests
    needs: [ci-fast-checks]
    # Only run on push or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Check if test-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'test'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping unit tests as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Load quarantined unit tests
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: quarantine
        run: |
          FILE="apps/web/tests/quarantine.json"
          UNIT_FILES=""
          UNIT_EXCLUDES=""

          if [ -f "$FILE" ]; then
            UNIT_FILES=$(jq -r '.unit // [] | join(" ")' "$FILE")
            UNIT_EXCLUDES=$(jq -r '.unit // [] | map("--exclude=" + .) | join(" ")' "$FILE")
          fi

          echo "unit_files=$UNIT_FILES" >> $GITHUB_OUTPUT
          echo "unit_excludes=$UNIT_EXCLUDES" >> $GITHUB_OUTPUT

          if [ -n "$UNIT_FILES" ]; then
            echo "has_unit=true" >> $GITHUB_OUTPUT
          else
            echo "has_unit=false" >> $GITHUB_OUTPUT
          fi

      - name: Run unit tests
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run test -- ${{ steps.quarantine.outputs.unit_excludes }}
        env:
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}

      - name: Run quarantined unit tests (retries)
        if: steps.check_changes.outputs.run_full_ci == 'true' && steps.quarantine.outputs.has_unit == 'true'
        continue-on-error: true
        run: cd apps/web && pnpm vitest run --config=vitest.config.mts --retry=2 ${{ steps.quarantine.outputs.unit_files }}
        env:
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}

  ci-e2e-tests:
    name: E2E Tests
    needs: [ci-build, neon-db]
    # Only run on push or PRs with testing label
    if: ${{ github.event_name == 'push' || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      run_full_ci: ${{ steps.check_changes.outputs.run_full_ci }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      # Check if E2E-related changes require running this job
      - name: Check for relevant changes
        id: check_changes
        uses: ./.github/actions/check-path-changes
        with:
          job-type: 'e2e'
          full-ci-label: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'testing') }}
          base-ref: ${{ github.base_ref }}
          event-name: ${{ github.event_name }}
          is-fork: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork }}

      # Skip remaining steps if no relevant changes
      - name: Skip notification
        if: steps.check_changes.outputs.run_full_ci != 'true'
        run: |
          echo "Skipping E2E tests as no critical paths were changed."
          echo "To force a full CI run, add the 'testing' label to the PR."
          exit 0

      # Continue with CI steps only if relevant changes detected or full-ci label present
      - name: Setup Node.js and pnpm
        if: steps.check_changes.outputs.run_full_ci == 'true'
        uses: ./.github/actions/setup-node-pnpm

      - name: Resolve Neon DB URL (job-local)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        id: resolve_neon
        uses: neondatabase/create-branch-action@v6
        with:
          project_id: ${{ vars.NEON_PROJECT_ID }}
          branch_name: ${{ needs.neon-db.outputs.branch_name }}
          role: neondb_owner
          api_key: ${{ secrets.NEON_API_KEY }}

      - name: Resolve DATABASE_URL for E2E
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          CANDIDATE="${{ steps.resolve_neon.outputs.db_url }}"
          SRC=""
          if [ -n "$CANDIDATE" ]; then
            echo "Using Neon DB URL from neon-db job outputs"
            echo "DATABASE_URL=$CANDIDATE" >> $GITHUB_ENV
            SRC="neon-job-output"
          else
            echo "No Neon ephemeral DB URL available from neon-db job."
            SRC="unresolved"
          fi
          echo "RESOLVED_DB_SOURCE=$SRC" >> $GITHUB_ENV

      - name: Fail if Neon DB URL is missing (E2E)
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: |
          if [[ -z "$DATABASE_URL" ]]; then
            echo "No Neon ephemeral DATABASE_URL available. Refusing to run E2E against production DB."
            exit 1
          fi

      - name: Run migrations for E2E DB
        if: steps.check_changes.outputs.run_full_ci == 'true'
        run: pnpm --filter=@jovie/web run drizzle:migrate
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          NODE_ENV: test
          GIT_BRANCH: ${{ github.ref_name }}
          ALLOW_PROD_MIGRATIONS: 'true'

      - name: Cache Playwright Browsers
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/cache@v5
        with:
          path: ~/.cache/ms-playwright
          key: ${{ runner.os }}-playwright-${{ hashFiles('pnpm-lock.yaml', 'playwright.config*.ts') }}
          restore-keys: |
            ${{ runner.os }}-playwright-

      - name: Install Playwright
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: pnpm --filter=@jovie/web exec playwright install chromium firefox --with-deps

      - name: Load quarantined E2E specs
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        id: quarantine
        run: |
          FILE="apps/web/tests/quarantine.json"
          QUARANTINED=()

          if [ -f "$FILE" ]; then
            mapfile -t QUARANTINED < <(jq -r '.e2e // [] | .[]' "$FILE")
          fi

          mapfile -t ALL_SPECS < <(git ls-files "apps/web/tests/e2e/**/*.spec.ts" "apps/web/tests/smoke/**/*.spec.ts")

          ALLOWED_SPECS=()
          for spec in "${ALL_SPECS[@]}"; do
            skip=false
            for quarantined in "${QUARANTINED[@]}"; do
              if [[ "$spec" == "$quarantined" ]]; then
                skip=true
                break
              fi
            done
            if [[ "$skip" == "false" ]]; then
              ALLOWED_SPECS+=("$spec")
            fi
          done

          echo "allowed_specs=${ALLOWED_SPECS[*]}" >> $GITHUB_OUTPUT
          echo "quarantined_specs=${QUARANTINED[*]}" >> $GITHUB_OUTPUT

          if [ ${#QUARANTINED[@]} -gt 0 ]; then
            echo "has_quarantine=true" >> $GITHUB_OUTPUT
          else
            echo "has_quarantine=false" >> $GITHUB_OUTPUT
          fi

      - name: E2E Smoke (PR to Preview)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && github.event_name == 'pull_request' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: |
          if [ -z "${{ steps.quarantine.outputs.allowed_specs }}" ]; then
            echo "No non-quarantined E2E specs to run."
            exit 0
          fi
          cd apps/web && pnpm playwright test -g @smoke --trace=retain-on-failure ${{ steps.quarantine.outputs.allowed_specs }}
        continue-on-error: ${{ github.event_name == 'pull_request' }}

      - name: E2E Full (Main Branch)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && github.ref == 'refs/heads/main' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        run: |
          if [ -z "${{ steps.quarantine.outputs.allowed_specs }}" ]; then
            echo "No non-quarantined E2E specs to run."
            exit 0
          fi
          cd apps/web && pnpm playwright test --reporter=line ${{ steps.quarantine.outputs.allowed_specs }}

      - name: E2E Quarantine (retries)
        if: ${{ steps.check_changes.outputs.run_full_ci == 'true' && steps.quarantine.outputs.has_quarantine == 'true' }}
        continue-on-error: true
        run: cd apps/web && pnpm playwright test --reporter=line --retries=2 ${{ steps.quarantine.outputs.quarantined_specs }}

      - name: Upload Playwright Report on Failure
        if: ${{ failure() && steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/upload-artifact@v6
        with:
          name: ${{ github.job }}-playwright-report-${{ github.run_id }}-${{ github.run_attempt }}
          path: apps/web/playwright-report/
          retention-days: 7

      - name: Upload Playwright Test Results on Failure
        if: ${{ failure() && steps.check_changes.outputs.run_full_ci == 'true' && (hashFiles('apps/web/tests/e2e/**') != '' || hashFiles('apps/web/tests/smoke/**') != '') }}
        uses: actions/upload-artifact@v6
        with:
          name: ${{ github.job }}-test-results-${{ github.run_id }}-${{ github.run_attempt }}
          path: apps/web/test-results/
          retention-days: 7

  ci-pr-vercel-preview:
    name: Preview Deploy (PR)
    # Only needs build - no DB dependencies for fast UI-only PRs
    needs: [ci-build]
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.repo.fork == false }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      deployment_url: ${{ steps.pr_deploy.outputs.deployment_url }}
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-node@v5
        with:
          node-version: 20
          package-manager-cache: false
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: Pull env (preview)
        run: vercel pull --yes --environment=preview --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build (PR preview)
        run: vercel build --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
      - name: Deploy (PR preview, fast deployment for UI-only changes)
        id: pr_deploy
        run: |
          # For fast preview PRs: use main secrets (no Neon dependency)
          # Fallback hierarchy for maximum compatibility
          POOLED_URL=""
          if [ -n "$DATABASE_URL_MAIN" ]; then
            POOLED_URL="$DATABASE_URL_MAIN"
            echo "Using main database URL"
          elif [ -n "$DATABASE_URL" ]; then
            POOLED_URL="$DATABASE_URL"
            echo "Using fallback database URL"
          else
            # Provide cheap stub for UI-only deployments that might not need DB
            POOLED_URL="postgresql://stub:stub@localhost:5432/main_stub"
            echo "Using stub database URL for UI-only deployment"
          fi

          # Deploy preview with DATABASE_URL injected only for this deployment
          deployment_url=$(vercel deploy --prebuilt \
            --env DATABASE_URL="$POOLED_URL" \
            --env GIT_BRANCH="${GIT_BRANCH}" \
            --token $VERCEL_TOKEN)

          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          # Use main secrets - no Neon dependency for fast deployments
          DATABASE_URL_MAIN: ${{ secrets.DATABASE_URL_MAIN }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GIT_BRANCH: ${{ github.head_ref || github.ref_name }}

  ci-summary:
    name: CI Summary
    if: ${{ always() && github.event_name == 'pull_request' }}
    needs:
      - ci-env-example-guard
      - ci-guardrails
      - ci-fast-checks
      - neon-db
      - drizzle-migration-guard
      - ci-drizzle-check
      - ci-fast
      - ci-pr-neon-migrate
      - ci-build
      - ci-unit-tests
      - ci-e2e-tests
      - ci-pr-vercel-preview
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      actions: read
      pull-requests: write
      contents: read
    steps:
      - name: Post CI summary to PR
        uses: actions/github-script@v8
        env:
          BUILD_RUN_FULL_CI: ${{ needs.ci-build.outputs.run_full_ci }}
          DRIZZLE_RUN_FULL_CI: ${{ needs.ci-drizzle-check.outputs.run_full_ci }}
          E2E_RUN_FULL_CI: ${{ needs.ci-e2e-tests.outputs.run_full_ci }}
          MIGRATION_GUARD_RUN_FULL_CI: ${{ needs.drizzle-migration-guard.outputs.run_full_ci }}
          PR_MIGRATE_RUN_FULL_CI: ${{ needs.ci-pr-neon-migrate.outputs.run_full_ci }}
          UNIT_RUN_FULL_CI: ${{ needs.ci-unit-tests.outputs.run_full_ci }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const runId = context.runId;

            const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id: runId,
              per_page: 100
            });

            const jobByName = new Map(
              jobsResponse.data.jobs.map(job => [job.name, job])
            );

            const formatDuration = (job) => {
              if (!job?.started_at || !job?.completed_at) return 'â€”';
              const start = new Date(job.started_at);
              const end = new Date(job.completed_at);
              const ms = Math.max(0, end - start);
              const minutes = Math.floor(ms / 60000);
              const seconds = Math.floor((ms % 60000) / 1000);
              return minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            };

            const resolveOutcome = (jobName, fallbackResult) => {
              const job = jobByName.get(jobName);
              if (!job) return { status: fallbackResult ?? 'not_run', duration: 'â€”' };
              return {
                status: job.conclusion || job.status || fallbackResult || 'unknown',
                duration: formatDuration(job)
              };
            };

            const summarizeStatus = (status) => {
              switch (status) {
                case 'success':
                  return 'âœ… Passed';
                case 'failure':
                  return 'âŒ Failed';
                case 'cancelled':
                  return 'âš ï¸ Cancelled';
                case 'skipped':
                  return 'âš ï¸ Skipped';
                case 'timed_out':
                  return 'âŒ Timed out';
                case 'not_run':
                  return 'âšªï¸ Not run';
                default:
                  return `âšªï¸ ${status}`;
              }
            };

            const deriveSkipReason = (jobKey, runFullCiFlag) => {
              if (runFullCiFlag === 'false') {
                return 'Skipped (path guard: no relevant changes)';
              }
              if (runFullCiFlag === '') {
                return 'Skipped (job not applicable)';
              }
              return jobKey === 'neon-db'
                ? 'Skipped (not required for this PR)'
                : 'Skipped (conditional job)';
            };

            const summaryRows = [
              { label: 'Env Example Guard', jobName: 'Env Example Guard' },
              { label: 'Guardrails', jobName: 'Guardrails (proxy + format)' },
              { label: 'Fast Checks', jobName: 'Fast checks (typecheck + lint)' },
              {
                label: 'Migration Guard',
                jobName: 'Migration Guard',
                runFullCi: process.env.MIGRATION_GUARD_RUN_FULL_CI
              },
              { label: 'Neon DB', jobName: 'Neon DB' },
              {
                label: 'Drizzle Check',
                jobName: 'Drizzle Check',
                runFullCi: process.env.DRIZZLE_RUN_FULL_CI
              },
              {
                label: 'Build',
                jobName: 'Build',
                runFullCi: process.env.BUILD_RUN_FULL_CI
              },
              {
                label: 'Unit Tests',
                jobName: 'Unit Tests',
                runFullCi: process.env.UNIT_RUN_FULL_CI
              },
              {
                label: 'E2E Tests',
                jobName: 'E2E Tests',
                runFullCi: process.env.E2E_RUN_FULL_CI
              },
              {
                label: 'DB Migrate (PR main)',
                jobName: 'DB Migrate (PR main)',
                runFullCi: process.env.PR_MIGRATE_RUN_FULL_CI
              },
              { label: 'Preview Deploy', jobName: 'Preview Deploy (PR)' }
            ];

            const rows = summaryRows.map((row) => {
              const outcome = resolveOutcome(row.jobName);
              const statusLabel = summarizeStatus(outcome.status);
              const timing = outcome.duration;
              let context = 'Executed';
              if (outcome.status === 'skipped' || outcome.status === 'not_run') {
                context = deriveSkipReason(row.label, row.runFullCi ?? '');
              }
              return `| ${row.label} | ${statusLabel} | ${context} | ${timing} |`;
            });

            const summaryBody = [
              '## CI Summary',
              '',
              'A crisp snapshot of this PR run â€” executed vs. skipped, with timing for every key lane.',
              '',
              '| Job | Status | Context | Time |',
              '| --- | ------ | ------- | ---- |',
              ...rows,
              '',
              `**Run:** [${runId}](${context.serverUrl}/${owner}/${repo}/actions/runs/${runId})`,
              ''
            ].join('\n');

            const existingComments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber
            });

            const botComment = existingComments.data.find(comment =>
              comment.user?.type === 'Bot' && comment.body?.startsWith('## CI Summary')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: summaryBody
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: summaryBody
              });
            }
  deploy:
    needs: [ci-build, ci-unit-tests, ci-e2e-tests] # Requires all CI jobs to pass before main deploy
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      deployment_url: ${{ steps.deploy.outputs.deployment_url }}
    env:
      # Main/staging must always use DATABASE_URL_MAIN; keep production secrets separate.
      DATABASE_URL_MAIN: ${{ secrets.DATABASE_URL_MAIN }}
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
    environment:
      name: Main Staging
      url: https://main.jov.ie
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: DB safety check (main - preflight)
        run: pnpm --filter=@jovie/web run drizzle:migrate:preflight
        env:
          DATABASE_URL: ${{ env.DATABASE_URL_MAIN }}
          GIT_BRANCH: main
      - name: DB migrate (main - Drizzle)
        run: pnpm --filter=@jovie/web run drizzle:migrate
        env:
          DATABASE_URL: ${{ env.DATABASE_URL_MAIN }}
          GIT_BRANCH: main
          ALLOW_PROD_MIGRATIONS: 'true'  # Allow automated migrations on main (staging environment)
      - name: DB seed (main)
        run: pnpm --filter=@jovie/web run db:seed
        env:
          DATABASE_URL: ${{ env.DATABASE_URL_MAIN }}
          GIT_BRANCH: main
          ALLOW_DB_SEED: '1'
        continue-on-error: false
      - name: Pull env (main)
        run: vercel pull --yes --environment=preview --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build
        run: vercel build --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_MAIN }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_MAIN }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
      - name: Deploy (prebuilt)
        id: deploy
        run: |
          deployment_url=$(vercel deploy --prebuilt --token ${{ secrets.VERCEL_TOKEN }})
          echo "deployment_url=$deployment_url" >> $GITHUB_OUTPUT
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  canary-health-gate:
    name: Canary Health Gate (staging)
    needs: [deploy]
    if: ${{ needs.deploy.result == 'success' }}
    uses: ./.github/workflows/canary-health-gate.yml
    with:
      deployment_url: ${{ needs.deploy.outputs.deployment_url }}
      fallback_health_url: https://main.jov.ie/api/health
    secrets:
      VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}

  staging-deploy-notify:
    name: Notify staging deploy
    needs: [deploy, canary-health-gate]
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve failure provenance
        id: failure-provenance
        if: ${{ always() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          api_url="${{ github.api_url }}/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs?per_page=100"
          response=$(curl -sS -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "$api_url")
          job_url=$(RESPONSE="$response" JOB_NAME="${{ github.job }}" python - <<'PY'
          import json
          import os

          data = json.loads(os.environ["RESPONSE"])
          job_name = os.environ["JOB_NAME"]
          job = next((item for item in data.get("jobs", []) if item.get("name") == job_name), None)
          print(job.get("html_url", "") if job else "")
          PY
          )

          if [ -z "$job_url" ]; then
            job_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}?check_suite_focus=true"
          fi

          echo "job_name=${{ github.job }}" >> "$GITHUB_OUTPUT"
          echo "job_url=$job_url" >> "$GITHUB_OUTPUT"

      - name: Slack notify (staging deploy)
        if: ${{ needs.deploy.result == 'success' && needs.canary-health-gate.result == 'success' && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#monitoring'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "âœ… Staging deployed: main.jov.ie",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Workflow", "value": "CI", "short": true },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack notify (staging deploy failed)
        if: ${{ (needs.deploy.result != 'success' || needs.canary-health-gate.result != 'success') && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-production'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "ðŸš¨ Staging deploy failed: main.jov.ie",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Failing job", "value": "${{ steps.failure-provenance.outputs.job_name }}", "short": true },
                    { "title": "Failing job URL", "value": "<${{ steps.failure-provenance.outputs.job_url }}|View job>", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # NOTE: Fast Lane system removed - now using pure trunk-based development
  # All changes merge to main and deploy directly to production

  deploy-prod:
    needs: [ci-build, ci-unit-tests, ci-e2e-tests]
    if: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      # Production deployment - uses production DATABASE_URL with migrations enabled
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      DATABASE_URL_MAIN: ${{ secrets.DATABASE_URL_MAIN }}
    environment:
      name: Production
      url: https://jov.ie
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/setup-node-pnpm
      - name: Install Vercel CLI
        run: pnpm add -g vercel@latest
      - name: DB safety check (production - preflight)
        run: pnpm --filter=@jovie/web run drizzle:migrate:preflight
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          GIT_BRANCH: main
          ALLOW_PROD_MIGRATIONS: 'true'
      - name: DB migrate (production) â€” requires backup and ALLOW_PROD_MIGRATIONS=true
        run: pnpm --filter=@jovie/web run drizzle:migrate:prod
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          GIT_BRANCH: main
          ALLOW_PROD_MIGRATIONS: true
        continue-on-error: false
      - name: Pull env (production)
        run: vercel pull --yes --environment=production --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      - name: Build (production)
        run: vercel build --prod --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.SUPABASE_URL_PROD }}
          NEXT_PUBLIC_SUPABASE_PUBLISHABLE_DEFAULT_KEY: ${{ secrets.SUPABASE_ANON_KEY_PROD }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_PROD }}
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ secrets.CLERK_PUBLISHABLE_KEY }}
      - name: Deploy (production, prebuilt)
        run: vercel deploy --prebuilt --prod --token ${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Resolve failure provenance
        id: failure-provenance
        if: ${{ always() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          api_url="${{ github.api_url }}/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs?per_page=100"
          response=$(curl -sS -H "Authorization: Bearer $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "$api_url")
          job_url=$(RESPONSE="$response" JOB_NAME="${{ github.job }}" python - <<'PY'
          import json
          import os

          data = json.loads(os.environ["RESPONSE"])
          job_name = os.environ["JOB_NAME"]
          job = next((item for item in data.get("jobs", []) if item.get("name") == job_name), None)
          print(job.get("html_url", "") if job else "")
          PY
          )

          if [ -z "$job_url" ]; then
            job_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}?check_suite_focus=true"
          fi

          echo "job_name=${{ github.job }}" >> "$GITHUB_OUTPUT"
          echo "job_url=$job_url" >> "$GITHUB_OUTPUT"

      - name: Slack notify (production deploy)
        if: ${{ success() && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-production'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "âœ… Production deployed: jov.ie",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Workflow", "value": "CI", "short": true },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Slack notify (production deploy failed)
        if: ${{ failure() && env.SLACK_WEBHOOK_URL != '' }}
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#alerts-critical'
          author_name: 'Deploy'
          custom_payload: |
            {
              "text": "ðŸ”¥ Production deploy failed: jov.ie",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "Branch", "value": "main", "short": true },
                    { "title": "Failing job", "value": "${{ steps.failure-provenance.outputs.job_name }}", "short": true },
                    { "title": "Failing job URL", "value": "<${{ steps.failure-provenance.outputs.job_url }}|View job>", "short": false },
                    { "title": "Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View>", "short": false }
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  lighthouse-ci-production:
    name: Lighthouse CI (Production)
    needs: [deploy-prod]
    if: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v6
      - uses: ./.github/actions/setup-node-pnpm
      - name: Run Lighthouse CI against production
        run: npx lhci autorun --config=.lighthouserc.json
