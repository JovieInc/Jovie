# Cursor Rules for Jovie Project

## STOP: Verify Tooling First

```bash
node --version   # MUST be v24.x (not 18, 20, or 22)
pnpm --version   # MUST be 9.15.4 (not npm or yarn)
```

**If wrong:** `nvm use 24` and `corepack prepare pnpm@9.15.4 --activate`

| Do | Don't |
|----|-------|
| `pnpm install` | `npm install` / `yarn` |
| `pnpm --filter web dev` | `cd apps/web && pnpm dev` |
| Run from repo root | Run from subdirectories |

See `agents.md` at repo root for full AI agent guidelines.

---

## ⚠️ CRITICAL: Infrastructure & Cost Guardrails

**Before creating any cron job, scheduled task, or polling loop, walk through this hierarchy IN ORDER. Use the first option that works:**

1. **Webhook / Event handler** — Can an external service (Stripe, Clerk, etc.) notify you? This is almost always the answer.
2. **Inline after-action** — Can the work happen right after the triggering action?
3. **On-demand / lazy eval** — Can the work happen when data is next accessed?
4. **Add to existing job** — Can you add logic to an existing cron/scheduled task?
5. **New scheduled job** — ONLY if all above fail, with explicit approval and PR justification.

**Hard Rules:**
- NEVER create a new Vercel cron entry without explicit human approval
- NEVER iterate over all users to call an external API (O(users) × runs/day = budget burn)
- NEVER poll external APIs for state you can receive via webhook
- NEVER add new job queue libraries (Bull, Agenda, etc.) — use the existing in-database queue
- Always calculate API call volume: `(calls/run) × (runs/day) × 30 = monthly calls`
- Include a **Cost Impact** section in PR description for any recurring external API calls

See `agents.md` → "Infrastructure & Scheduling Guardrails" for full details.

---

## ⚠️ CRITICAL: BRANCH PROTECTION RULES

### **NEVER PUSH TO PREVIEW OR MAIN**
- **ONLY push to `develop` branch**
- **NEVER push directly to `preview` or `main` branches**
- The CI/CD pipeline handles all promotions automatically
- If pipeline is stuck, fix issues on `develop` and let CI handle the rest
- Direct pushes to protected branches will be rejected and can break the pipeline

### **Branch Protection**
- `preview` and `main` are protected branches
- All changes must go through the CI/CD pipeline
- Auto-promote workflows handle `develop → preview → main` progression
- Manual intervention should only be done on `develop` branch

## Project Overview

Jovie is a Next.js 15 application with Clerk authentication and Neon PostgreSQL database (migrated from Supabase). The project uses Drizzle ORM and Statsig for feature flags.

## Technology Stack

- **Runtime**: Node.js 24.0.0 (required)
- **Package Manager**: pnpm 9.15.4 (required)
- **Frontend**: Next.js 15 (App Router)
- **Database**: Neon PostgreSQL with Drizzle ORM
- **Authentication**: Clerk
- **Feature Flags**: Statsig for experimentation and feature management
- **Styling**: Tailwind CSS v4
- **Linting**: Biome
- **Testing**: Vitest + Playwright
- **Monorepo**: Turborepo
- **Deployment**: Vercel

## Critical Guidelines

### 1. Feature Flags with Statsig

**ALWAYS use Statsig for feature flags:**

```typescript
// ✅ CORRECT: Use Statsig feature gates
import { useFeatureGate } from '@/lib/flags/client';
import { STATSIG_FLAGS } from '@/lib/flags';

export function MyComponent() {
  const { value: tippingEnabled } = useFeatureGate(STATSIG_FLAGS.TIPPING);
  const { value: notificationsEnabled } = useFeatureGate(STATSIG_FLAGS.NOTIFICATIONS);

  return (
    <div>
      {tippingEnabled && <TippingComponent />}
      {notificationsEnabled && <NotificationsComponent />}
    </div>
  );
}

// Server-side usage:
import { checkGateForUser } from '@/lib/flags/server';
import { STATSIG_FLAGS } from '@/lib/flags';

const isEnabled = await checkGateForUser(STATSIG_FLAGS.TIPPING, { userID: userId });
```

**Available feature flags (see `lib/statsig/flags.ts` for full list):**
- `TIPPING` - Enable tipping functionality
- `NOTIFICATIONS` - Enable notification system
- `ARTIST_SEARCH` - Controls artist search functionality
- `TIP_PROMO` - Controls tip promotion features
- `CONTACTS` - Gate artist contacts manager
- `AVATAR_UPLOADER` - Enable avatar upload with drag/drop

### 2. Clerk-Supabase Integration

**ALWAYS use the native integration method:**

```typescript
// ✅ CORRECT: Use native integration
import { useSession } from '@clerk/nextjs';
import { createClient } from '@supabase/supabase-js';

function createClerkSupabaseClient() {
  const { session } = useSession();

  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_KEY!,
    {
      async accessToken() {
        return session?.getToken() ?? null;
      },
    }
  );
}
```

**NEVER use JWT templates (deprecated):**

```typescript
// ❌ DO NOT use JWT templates
const token = await getToken({ template: 'supabase' });
```

### 3. RLS Policies

**ALWAYS use auth.jwt() for user identification:**

```sql
-- ✅ CORRECT: Use auth.jwt() for RLS
create policy "User can view own data" on "users"
for select to authenticated using (
  auth.jwt()->>'sub' = user_id
);
```

### 4. Component Patterns

**Use the established patterns:**

```typescript
// ✅ CORRECT: Client component with Clerk integration
'use client';
import { useSession } from '@clerk/nextjs';
import { createClient } from '@supabase/supabase-js';

export function MyComponent() {
  const { session } = useSession();

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_KEY!,
    {
      async accessToken() {
        return session?.getToken() ?? null;
      },
    }
  );

  // Component logic here
}
```

### 5. Error Handling

**Always handle errors gracefully:**

```typescript
const { data, error } = await supabase.from('table').select('*');

if (error) {
  console.error('Database error:', error);
  // Handle error appropriately
  return;
}
```

### 6. TypeScript

**Use proper typing:**

```typescript
interface User {
  id: string;
  clerk_id: string;
  email: string;
  created_at: string;
}

const { data: users, error } = await supabase
  .from('users')
  .select('*')
  .returns<User[]>();
```

## File Structure

- `app/` - Next.js App Router pages and layouts
- `components/` - Reusable React components
- `lib/` - Utility functions and configurations
- `supabase/` - Database migrations and functions
- `types/` - TypeScript type definitions
- `tests/` - Test files

## Environment Variables

Required environment variables:

```bash
# Clerk
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_KEY=your-anon-key

# Statsig
NEXT_PUBLIC_STATSIG_CLIENT_KEY=client-<your-statsig-client-key>

# Spotify
SPOTIFY_CLIENT_ID=your-spotify-client-id
SPOTIFY_CLIENT_SECRET=your-spotify-client-secret
```

## Database Schema

Key tables:

- `users` - User accounts (Clerk ID mapping)
- `artists` - Artist profiles
- `social_links` - Social media links
- `releases` - Music releases
- `click_events` - Analytics data

## Testing Guidelines

1. **Unit Tests**: Use Vitest for component testing
2. **E2E Tests**: Use Playwright for end-to-end testing
3. **Database Tests**: Test RLS policies with multiple users
4. **Authentication Tests**: Verify Clerk integration works correctly
5. **Feature Flag Tests**: Test components with different flag states

## Code Style

- Use TypeScript for all new code
- Follow existing component patterns
- Use Tailwind CSS for styling
- Prefer functional components with hooks
- Use proper error boundaries and loading states

## Security Guidelines

1. **Always enable RLS** on user data tables
2. **Use auth.jwt()** for user identification in policies
3. **Validate user permissions** before database operations
4. **Never expose sensitive data** in client-side code
5. **Use environment variables** for all secrets

## Migration Guidelines

When updating Clerk-Supabase integration:

1. **Remove JWT templates** from Clerk dashboard
2. **Update client configuration** to use `accessToken()`
3. **Update RLS policies** to use `auth.jwt()->>'sub'`
4. **Test thoroughly** with existing data
5. **Verify data isolation** between users

## Common Patterns

### Feature Flag Usage

```typescript
import { useFeatureGate } from '@/lib/flags/client';
import { STATSIG_FLAGS } from '@/lib/flags';

export function MyComponent() {
  const { value: tippingEnabled } = useFeatureGate(STATSIG_FLAGS.TIPPING);
  const { value: contactsEnabled } = useFeatureGate(STATSIG_FLAGS.CONTACTS);

  return (
    <div>
      {tippingEnabled && <TippingComponent />}
      {contactsEnabled && <ContactsComponent />}
    </div>
  );
}
```

### Form Handling

```typescript
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | undefined>();

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  setLoading(true);
  setError(undefined);

  try {
    const supabase = createClerkSupabaseClient();
    const { error } = await supabase.from('table').insert(data);

    if (error) throw error;
    // Handle success
  } catch (error) {
    setError('Failed to save data');
  } finally {
    setLoading(false);
  }
};
```

### Data Fetching

```typescript
const [data, setData] = useState<User[]>([]);
const [loading, setLoading] = useState(true);

useEffect(() => {
  const fetchData = async () => {
    try {
      const supabase = createClerkSupabaseClient();
      const { data, error } = await supabase.from('users').select('*');

      if (error) throw error;
      setData(data || []);
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

## Resources

- [Clerk Supabase Integration](https://clerk.com/docs/raw/integrations/databases/supabase.mdx)
- [Supabase RLS Documentation](https://supabase.com/docs/guides/auth/row-level-security)
- [Statsig Documentation](https://docs.statsig.com/)
- [Next.js App Router](https://nextjs.org/docs/app)
- [Tailwind CSS](https://tailwindcss.com/docs)

## AI Tool Verification

Before suggesting code changes, verify:

1. ✅ Uses native Clerk-Supabase integration
2. ✅ Uses Statsig for feature flags
3. ✅ Implements proper RLS policies
4. ✅ Handles errors gracefully
5. ✅ Uses TypeScript types
6. ✅ Follows existing patterns
7. ✅ Maintains security best practices
