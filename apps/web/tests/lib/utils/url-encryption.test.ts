/**
 * URL Encryption Tests
 * Tests for URL encryption and utility functions
 */

import crypto from 'crypto';
import { afterEach, describe, expect, it, vi } from 'vitest';
import {
  type EncryptionResult,
  extractDomain,
  generateShortId,
  isValidUrl,
  sanitizeUrlForLogging,
  simpleDecryptUrl,
  simpleEncryptUrl,
} from '@/lib/utils/url-encryption';
import {
  decryptUrl,
  encryptUrl,
  generateSignedToken,
} from '@/lib/utils/url-encryption.server';

describe('URL Encryption', () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('encryptUrl', () => {
    it('should encrypt a URL and return encryption result', () => {
      const url = 'https://example.com/path?query=value';

      const result = encryptUrl(url);

      expect(result.encrypted).toBeDefined();
      expect(result.encrypted).not.toBe(url);
    });

    it('should include IV in result', () => {
      const url = 'https://example.com';

      const result = encryptUrl(url);

      expect(result.iv).toBeDefined();
      expect(result.iv.length).toBeGreaterThan(0);
    });

    it('should produce different ciphertext for same input (random IV)', () => {
      const url = 'https://example.com';

      const result1 = encryptUrl(url);
      const result2 = encryptUrl(url);

      expect(result1.encrypted).not.toBe(result2.encrypted);
      expect(result1.iv).not.toBe(result2.iv);
    });

    it('should include auth tag and support round trip decryption', () => {
      const url = 'https://example.com/secure';

      const result = encryptUrl(url);
      const decrypted = decryptUrl(result);

      expect(result.authTag).toBeDefined();
      expect(result.authTag.length).toBeGreaterThan(0);
      expect(decrypted).toBe(url);
    });

    it('should throw error when cipher creation fails', () => {
      const url = 'https://example.com/fallback';
      const cipherSpy = vi
        .spyOn(crypto, 'createCipheriv')
        .mockImplementation(() => {
          throw new Error('cipher failure');
        });

      expect(() => encryptUrl(url)).toThrow('Failed to encrypt URL');
      expect(cipherSpy).toHaveBeenCalled();
    });
  });

  describe('decryptUrl', () => {
    it('should decrypt values generated by encryptUrl', () => {
      const url = 'https://example.com/path?query=value';

      const encrypted = encryptUrl(url);
      const decrypted = decryptUrl(encrypted);

      expect(decrypted).toBe(url);
    });

    it('should throw error when encryption metadata is missing (legacy data)', () => {
      const url = 'https://example.com';
      const legacyResult: EncryptionResult = {
        encrypted: Buffer.from(url).toString('base64'),
        iv: '',
        authTag: '',
        salt: '',
      };

      // Legacy data without proper encryption metadata should throw an error
      expect(() => decryptUrl(legacyResult)).toThrow('Failed to decrypt URL');
    });

    it('should throw error when encrypted payload is tampered', () => {
      const url = 'https://example.com/protected';
      const encrypted = encryptUrl(url);
      const tampered: EncryptionResult = {
        ...encrypted,
        encrypted: encrypted.encrypted.slice(0, -2) + 'aa',
      };

      expect(() => decryptUrl(tampered)).toThrow();
    });
  });

  describe('simpleEncryptUrl', () => {
    it('should encode URL to base64', () => {
      const url = 'https://example.com';

      const encrypted = simpleEncryptUrl(url);

      expect(encrypted).toBe(Buffer.from(url).toString('base64'));
    });

    it('should handle special characters', () => {
      const url = 'https://example.com/path?foo=bar&baz=qux#fragment';

      const encrypted = simpleEncryptUrl(url);
      const decrypted = simpleDecryptUrl(encrypted);

      expect(decrypted).toBe(url);
    });

    it('should handle unicode characters', () => {
      const url = 'https://example.com/日本語';

      const encrypted = simpleEncryptUrl(url);
      const decrypted = simpleDecryptUrl(encrypted);

      expect(decrypted).toBe(url);
    });
  });

  describe('simpleDecryptUrl', () => {
    it('should decode base64 back to URL', () => {
      const url = 'https://example.com';
      const encoded = Buffer.from(url).toString('base64');

      const decrypted = simpleDecryptUrl(encoded);

      expect(decrypted).toBe(url);
    });
  });

  describe('generateShortId', () => {
    it('should generate ID of default length (12)', () => {
      const id = generateShortId();

      expect(id.length).toBe(12);
    });

    it('should generate ID of custom length', () => {
      const id = generateShortId(8);

      expect(id.length).toBe(8);
    });

    it('should only contain alphanumeric characters', () => {
      const id = generateShortId(100);

      expect(id).toMatch(/^[a-zA-Z0-9]+$/);
    });

    it('should generate unique IDs', () => {
      const ids = new Set<string>();

      for (let i = 0; i < 100; i++) {
        ids.add(generateShortId());
      }

      // All 100 IDs should be unique
      expect(ids.size).toBe(100);
    });
  });

  describe('generateSignedToken', () => {
    it('should generate a 64-character hex string', () => {
      const token = generateSignedToken();

      expect(token.length).toBe(64);
      expect(token).toMatch(/^[a-f0-9]+$/);
    });

    it('should generate unique tokens', () => {
      const tokens = new Set<string>();

      for (let i = 0; i < 100; i++) {
        tokens.add(generateSignedToken());
      }

      expect(tokens.size).toBe(100);
    });
  });

  describe('isValidUrl', () => {
    it('should return true for valid HTTP URLs', () => {
      expect(isValidUrl('http://example.com')).toBe(true);
      expect(isValidUrl('http://example.com/path')).toBe(true);
      expect(isValidUrl('http://example.com:8080')).toBe(true);
    });

    it('should return true for valid HTTPS URLs', () => {
      expect(isValidUrl('https://example.com')).toBe(true);
      expect(isValidUrl('https://example.com/path?query=value')).toBe(true);
      expect(isValidUrl('https://sub.domain.example.com')).toBe(true);
    });

    it('should return false for invalid URLs', () => {
      expect(isValidUrl('not-a-url')).toBe(false);
      expect(isValidUrl('example.com')).toBe(false);
      expect(isValidUrl('/path/only')).toBe(false);
      expect(isValidUrl('')).toBe(false);
    });

    it('should return false for non-HTTP/HTTPS protocols', () => {
      expect(isValidUrl('ftp://example.com')).toBe(false);
      expect(isValidUrl('mailto:user@example.com')).toBe(false);
      expect(isValidUrl('javascript:alert(1)')).toBe(false);
      expect(isValidUrl('file:///path/to/file')).toBe(false);
    });
  });

  describe('extractDomain', () => {
    it('should extract domain from URL', () => {
      expect(extractDomain('https://example.com/path')).toBe('example.com');
      expect(extractDomain('https://sub.example.com/path')).toBe(
        'sub.example.com'
      );
    });

    it('should remove www prefix', () => {
      expect(extractDomain('https://www.example.com')).toBe('example.com');
      expect(extractDomain('http://www.example.com/path')).toBe('example.com');
    });

    it('should lowercase the domain', () => {
      expect(extractDomain('https://EXAMPLE.COM')).toBe('example.com');
      expect(extractDomain('https://Example.Com/Path')).toBe('example.com');
    });

    it('should return empty string for invalid URLs', () => {
      expect(extractDomain('not-a-url')).toBe('');
      expect(extractDomain('')).toBe('');
    });
  });

  describe('sanitizeUrlForLogging', () => {
    it('should preserve URL without sensitive params', () => {
      const url = 'https://example.com/path?foo=bar';

      const sanitized = sanitizeUrlForLogging(url);

      expect(sanitized).toBe('https://example.com/path?foo=bar');
    });

    it('should remove token parameter', () => {
      const url = 'https://example.com/path?token=secret123&foo=bar';

      const sanitized = sanitizeUrlForLogging(url);

      expect(sanitized).toBe('https://example.com/path?foo=bar');
      expect(sanitized).not.toContain('token');
      expect(sanitized).not.toContain('secret123');
    });

    it('should remove key parameter', () => {
      const url = 'https://example.com/path?key=api-key-123';

      const sanitized = sanitizeUrlForLogging(url);

      expect(sanitized).toBe('https://example.com/path');
      expect(sanitized).not.toContain('key');
    });

    it('should remove auth parameter', () => {
      const url = 'https://example.com/path?auth=bearer-token';

      const sanitized = sanitizeUrlForLogging(url);

      expect(sanitized).not.toContain('auth');
    });

    it('should remove password parameter', () => {
      const url = 'https://example.com/path?password=secret';

      const sanitized = sanitizeUrlForLogging(url);

      expect(sanitized).not.toContain('password');
    });

    it('should remove secret parameter', () => {
      const url = 'https://example.com/path?secret=hidden';

      const sanitized = sanitizeUrlForLogging(url);

      expect(sanitized).not.toContain('secret');
    });

    it('should remove multiple sensitive params', () => {
      const url =
        'https://example.com/path?token=a&key=b&auth=c&password=d&secret=e&safe=keep';

      const sanitized = sanitizeUrlForLogging(url);

      expect(sanitized).toBe('https://example.com/path?safe=keep');
    });

    it('should return [Invalid URL] for invalid URLs', () => {
      expect(sanitizeUrlForLogging('not-a-url')).toBe('[Invalid URL]');
      expect(sanitizeUrlForLogging('')).toBe('[Invalid URL]');
    });
  });
});
